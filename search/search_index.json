{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Welcome to MkDocs For full documentation visit mkdocs.org . Commands mkdocs new [dir-name] - Create a new project. mkdocs serve - Start the live-reloading docs server. mkdocs build - Build the documentation site. mkdocs -h - Print help message and exit. Project layout mkdocs.yml # The configuration file. docs/ index.md # The documentation homepage. ... # Other markdown pages, images and other files.","title":"Home"},{"location":"#welcome-to-mkdocs","text":"For full documentation visit mkdocs.org .","title":"Welcome to MkDocs"},{"location":"#commands","text":"mkdocs new [dir-name] - Create a new project. mkdocs serve - Start the live-reloading docs server. mkdocs build - Build the documentation site. mkdocs -h - Print help message and exit.","title":"Commands"},{"location":"#project-layout","text":"mkdocs.yml # The configuration file. docs/ index.md # The documentation homepage. ... # Other markdown pages, images and other files.","title":"Project layout"},{"location":"about/","text":"Why this Repo ? I find this repo, a way to track all my research through my final year project. In this repo you will find all material and useful resssources for computer vision and artificial intelligence. For more information you can reach me at mamanedodoo@gmail.com","title":"About"},{"location":"about/#why-this-repo","text":"I find this repo, a way to track all my research through my final year project. In this repo you will find all material and useful resssources for computer vision and artificial intelligence. For more information you can reach me at mamanedodoo@gmail.com","title":"Why this Repo ?"},{"location":"articles/git/","text":"Git Tutorial 1. D\u00e9finition What is \"version control\", and why should you care ? Version control is a system that records changes to a file or set of files over time so that you can recall specific versions later. Any type of files can be version controlled. In this tutorial, we will use software source code as the files beign version controlled. A VCS allows you to revert files to a previous state, the entire project to a previous state, compare changes over time, see who last modified something that might be causing a problem, who introduced an issue and when, and more. Using a VCS also generally means that if you screw things up orr lose files, you can easily recover. In addition yu get all this for very little overhead. 2. Types de syst\u00e8mes de gestion de version 2.1 Local Version Control System Local Version Control Systems, had a simple database that kept all changes to files under revision control. Exemple: RCS 2.2 Centralised Version Control System Les syst\u00e8mes de gestion de versions locaux, ne permettent pas de collaborer entre les d\u00e9veloppeurs d'un projet. Donc, il y a lieu de mettre en place un syst\u00e8me de gestion de version qui r\u00e9pond au besoin de collaboration et de suivi du travail de chaque d\u00e9veloppeur. D'o\u00f9 la migration vers des syst\u00e8mes de gestion centralis\u00e9s. Ces syst\u00e8mes poss\u00e8de un server central o\u00f9 les fichiers versionn\u00e9s sont stock\u00e9s. Chaque d\u00e9veloppeur peut faire une requ\u00eate des fichiers du projet pour travailler localement. Exemple: Subversion , Perforce . Les avantages de ce type de syst\u00e8me par rapport aux precedents est le suivi du travail de chaque developpeur (qui a fait Quoi? Quand? Etc). Comme toute l'historique des versions est stock\u00e9e sur le server (uniquement le server), il y a des risques tels que: Interruption de la collaboration lorsque le server tombe en panne Perte des donn\u00e9es du server Perte de toute l'historique sur les versions du projet Tous ces probl\u00e8mes sont dus \u00e0 la d\u00e9pendance au server. Pour pallier cela, il faut des syst\u00e8mes de gestion de version, o\u00f9 l'historique des versions n'est pas centralis\u00e9, donc elle doit \u00eatre pr\u00e9sente non seulement sur le server mais aussi au niveau de ses clients (dans notre cas les machines des d\u00e9veloppeurs qui participe \u00e0 un projet). Ce type de syst\u00e8mes sont app\u00e9l\u00e9s des syst\u00e8mes de gestion distribu\u00e9s (ou centralis\u00e9s). 2.3 Distributed Versions Control System Dans les syst\u00e8mes de gestion de version distribu\u00e9s, lors d'une requ\u00eate au server, c'est une copie de toute l'historique des versions qui est transmise au client. Exemple : Git , Mercurial , Bazaar , Dars . 3. Pr\u00e9sentation de Git Git est un syst\u00e8mes de gestion de versions distribu\u00e9, developp\u00e9 par Linus Torvalds (Pour \u00eatre plus pr\u00e9cis la communaut\u00e9 de d\u00e9veloppement du Kernel Linux) en 2005. Git a \u00e9t\u00e9 con\u00e7u pour r\u00e9pondre aux besoins suivant: Rapidit\u00e9 (speed) Simpe design Excellent Syst\u00e8me de branching Completement distribu\u00e9 Capable de g\u00e9rer de grands projets tels que Linux Kernel Git est un syst\u00e8me de gestion de versions d\u00e9centralis\u00e9. Votre copie de travail ainsi qu\u2019une copie int\u00e9grale de l\u2019historique complet du projet se trouvent sur votre machine, sur le serveur, et sur tous les autres ordinateurs h\u00e9bergeant une copie du projet. 4. Installation et configuration V\u00e9rifier si Git est installer sur votre syst\u00e8me $ git --version Installer Git sur Linux $ sudo apt-get git Pour configurer git on utilise la commande git config . Trois port\u00e9e pour ces configurations Local : lorsqu'on veut configurer git pour seulement un repository sp\u00e9cifique on utilise la commande git config suivi de la configuration qu'on veut faire. (fichier de configuration disponible dans le fichier .git/config du repos) Global : lorsqu'on veut faire une configuration pour tous les nos repos (niveau user), on utilise la commande git config --global suivi de la configuration qu'on veut faire.(fichier de configuration disponible dans le fichier ~/.gitconfig ou ~/.config/git/config) System : Pour configurer git au niveau syst\u00e8me (pour tous les utilisateurs du syst\u00e8me), on utilise git config --system suivi de la configuration.(fichier de configuration disponible dans le fichier /etc/gitconfig) Git aura besoin de votre nom et adresse mail pour faire des commits: $ git config --global user.name \"votre_nom\" $ git config --global user.email \"votre_adresse_mail\" Quelques configurations : Choisir un \u00e9diteur par d\u00e9faut: git config --global core.editor editor_name Commande pour lister les configurations : git config --list 4. Fonctionnement de Git 6. Pratique Dans cette partie nous allons explorer git \u00e0 l'aide d'un exemple. 6.1 Enonc\u00e9 Deux d\u00e9veloppeurs Tom et Jerry decide de collaborer sur un projet informatique: mise en place d'une librairie proposant des fonctions destiner \u00e0 la manipulation des chaines de caract\u00e8res. Pour collaborer, ils vont utiliser l'outil Git. Nous allons simuler tous cela \u00e0 l'aide de notre machine: tom et jerry seront des utilisateurs que nous allons cr\u00e9er. Et pour server nous allons cr\u00e9er un autre utilisateur gitServer, qui servira de server 6.2 Cr\u00e9ation des utilisateurs et configurations 6.2.1 Cr\u00e9ation de gitServer Cr\u00e9ation de l'utilisateur gitServer $ sudo useradd -d /home/gitServer -m -s /bin/bash gitServer $ passwd gitServer Configurer Git $ git config --global user.name \"gitServer\" $ git config --global user.email \"gitServer@gmail.com\" Cr\u00e9er un repertoire project.git: $ mkdir project.git $ cd project.git $ git config --list $ git --bare init 6.2.2 Cr\u00e9ation de l'utilisateur Tom Cr\u00e9ation de l'utilisateur Tom: $ sudo useradd -d /home/gitServer -m -s /bin/bash tom $ passwd tom Configurer Git pour Tom $ git config --global user.name \"tom\" $ git config --global user.email \"tom@gmail.com 6.2.3 Cr\u00e9ation de l'utilisateur Jerry Cr\u00e9ation de l'utilisateur Jerry: $ sudo useradd -d /home/jerry -m -s /bin/bash jerry $ passwd jerry Configurer Git pour Jerry $ git config --global user.name \"jerry\" $ git config --global user.email \"jerry@gmail.com 6.3 G\u00e9n\u00e9ration des cl\u00e8s (RSA Key pair) Pour gitServer: $ ssh-keygen Recuperer l'adresse l'IP $ ifconfig Pour Tom: $ ssh-keygen $ ssh-copy-id -i ~/.ssh/id_rsa.pub gitServe@ip_adress Pour Jerry: $ ssh-keygen $ ssh-copy-id -i ~/.ssh/id_rsa.pub gitServe@ip_adress 6.4 D\u00e9veloppement de la biblioth\u00e8que Tom cr\u00e9e un repository local Se placer dans le repertoire de Tom: $ su tom $ pwd Cr\u00e9er le repertoire tom_repo pour le projet $ mkdir tom_repo $ cd tom_repo D\u00e9clarer le repertoire comme \u00e9tant un depot git $ pwd $ git init Ajouter un fichier README.md qui d\u00e9crit le projet $ touch README.md Verifier le status $ git status -s Ajouter le fichier README.md au staging area $ git add README.md $ git status -s Ajouter le fichier README au depot git $ git commit -m \"Ajout de README\" $ git status -s Relier le dep\u00f4t local au depot distant project.git qui se trouve dans le server gitServer: $ git remote add origin gitServer@ip_address:project Envoyer vers le server $ git push origin master Jerry clone le repo et cr\u00e9e le fichier strings.c clone le repo se trouvant sur gitServer $ git clone gitServer@ip_address:project $ cd project consulte le repo $ ls $ git log $ git status -s Ajoute un fichier strings.c $ nano strings.c $ git status -s Ajouter le fichier au staging Area $ git add strings.c $ git status -s Faire un commit $ git commit -m \"Ajout du fichier strings.c\" $ git status -s Envoyer au server git push origin master Tom clone le repo pour modifier README et consulter les changements effectu\u00e9s par Jerry clone le repository $ git clone gitServer@ip_adress:project $ cd project consulte les modifications $ git log Modifie la description du projet $ nano README.md $ git add README.md $ git commit -m \"Modification du fichier README.md\" Envoyer au server $ git push origin master","title":"Version control"},{"location":"articles/git/#git-tutorial","text":"","title":"Git Tutorial"},{"location":"articles/git/#1-definition","text":"What is \"version control\", and why should you care ? Version control is a system that records changes to a file or set of files over time so that you can recall specific versions later. Any type of files can be version controlled. In this tutorial, we will use software source code as the files beign version controlled. A VCS allows you to revert files to a previous state, the entire project to a previous state, compare changes over time, see who last modified something that might be causing a problem, who introduced an issue and when, and more. Using a VCS also generally means that if you screw things up orr lose files, you can easily recover. In addition yu get all this for very little overhead.","title":"1. D\u00e9finition"},{"location":"articles/git/#2-types-de-systemes-de-gestion-de-version","text":"","title":"2. Types de syst\u00e8mes de gestion de version"},{"location":"articles/git/#21-local-version-control-system","text":"Local Version Control Systems, had a simple database that kept all changes to files under revision control. Exemple: RCS","title":"2.1 Local Version Control System"},{"location":"articles/git/#22-centralised-version-control-system","text":"Les syst\u00e8mes de gestion de versions locaux, ne permettent pas de collaborer entre les d\u00e9veloppeurs d'un projet. Donc, il y a lieu de mettre en place un syst\u00e8me de gestion de version qui r\u00e9pond au besoin de collaboration et de suivi du travail de chaque d\u00e9veloppeur. D'o\u00f9 la migration vers des syst\u00e8mes de gestion centralis\u00e9s. Ces syst\u00e8mes poss\u00e8de un server central o\u00f9 les fichiers versionn\u00e9s sont stock\u00e9s. Chaque d\u00e9veloppeur peut faire une requ\u00eate des fichiers du projet pour travailler localement. Exemple: Subversion , Perforce . Les avantages de ce type de syst\u00e8me par rapport aux precedents est le suivi du travail de chaque developpeur (qui a fait Quoi? Quand? Etc). Comme toute l'historique des versions est stock\u00e9e sur le server (uniquement le server), il y a des risques tels que: Interruption de la collaboration lorsque le server tombe en panne Perte des donn\u00e9es du server Perte de toute l'historique sur les versions du projet Tous ces probl\u00e8mes sont dus \u00e0 la d\u00e9pendance au server. Pour pallier cela, il faut des syst\u00e8mes de gestion de version, o\u00f9 l'historique des versions n'est pas centralis\u00e9, donc elle doit \u00eatre pr\u00e9sente non seulement sur le server mais aussi au niveau de ses clients (dans notre cas les machines des d\u00e9veloppeurs qui participe \u00e0 un projet). Ce type de syst\u00e8mes sont app\u00e9l\u00e9s des syst\u00e8mes de gestion distribu\u00e9s (ou centralis\u00e9s).","title":"2.2 Centralised Version Control System"},{"location":"articles/git/#23-distributed-versions-control-system","text":"Dans les syst\u00e8mes de gestion de version distribu\u00e9s, lors d'une requ\u00eate au server, c'est une copie de toute l'historique des versions qui est transmise au client. Exemple : Git , Mercurial , Bazaar , Dars .","title":"2.3 Distributed Versions Control System"},{"location":"articles/git/#3-presentation-de-git","text":"Git est un syst\u00e8mes de gestion de versions distribu\u00e9, developp\u00e9 par Linus Torvalds (Pour \u00eatre plus pr\u00e9cis la communaut\u00e9 de d\u00e9veloppement du Kernel Linux) en 2005. Git a \u00e9t\u00e9 con\u00e7u pour r\u00e9pondre aux besoins suivant: Rapidit\u00e9 (speed) Simpe design Excellent Syst\u00e8me de branching Completement distribu\u00e9 Capable de g\u00e9rer de grands projets tels que Linux Kernel Git est un syst\u00e8me de gestion de versions d\u00e9centralis\u00e9. Votre copie de travail ainsi qu\u2019une copie int\u00e9grale de l\u2019historique complet du projet se trouvent sur votre machine, sur le serveur, et sur tous les autres ordinateurs h\u00e9bergeant une copie du projet.","title":"3. Pr\u00e9sentation de Git"},{"location":"articles/git/#4-installation-et-configuration","text":"V\u00e9rifier si Git est installer sur votre syst\u00e8me $ git --version Installer Git sur Linux $ sudo apt-get git Pour configurer git on utilise la commande git config . Trois port\u00e9e pour ces configurations Local : lorsqu'on veut configurer git pour seulement un repository sp\u00e9cifique on utilise la commande git config suivi de la configuration qu'on veut faire. (fichier de configuration disponible dans le fichier .git/config du repos) Global : lorsqu'on veut faire une configuration pour tous les nos repos (niveau user), on utilise la commande git config --global suivi de la configuration qu'on veut faire.(fichier de configuration disponible dans le fichier ~/.gitconfig ou ~/.config/git/config) System : Pour configurer git au niveau syst\u00e8me (pour tous les utilisateurs du syst\u00e8me), on utilise git config --system suivi de la configuration.(fichier de configuration disponible dans le fichier /etc/gitconfig) Git aura besoin de votre nom et adresse mail pour faire des commits: $ git config --global user.name \"votre_nom\" $ git config --global user.email \"votre_adresse_mail\" Quelques configurations : Choisir un \u00e9diteur par d\u00e9faut: git config --global core.editor editor_name Commande pour lister les configurations : git config --list","title":"4. Installation et configuration"},{"location":"articles/git/#4-fonctionnement-de-git","text":"","title":"4. Fonctionnement de Git"},{"location":"articles/git/#6-pratique","text":"Dans cette partie nous allons explorer git \u00e0 l'aide d'un exemple.","title":"6. Pratique"},{"location":"articles/git/#61-enonce","text":"Deux d\u00e9veloppeurs Tom et Jerry decide de collaborer sur un projet informatique: mise en place d'une librairie proposant des fonctions destiner \u00e0 la manipulation des chaines de caract\u00e8res. Pour collaborer, ils vont utiliser l'outil Git. Nous allons simuler tous cela \u00e0 l'aide de notre machine: tom et jerry seront des utilisateurs que nous allons cr\u00e9er. Et pour server nous allons cr\u00e9er un autre utilisateur gitServer, qui servira de server","title":"6.1 Enonc\u00e9"},{"location":"articles/git/#62-creation-des-utilisateurs-et-configurations","text":"","title":"6.2 Cr\u00e9ation des utilisateurs et configurations"},{"location":"articles/git/#621-creation-de-gitserver","text":"Cr\u00e9ation de l'utilisateur gitServer $ sudo useradd -d /home/gitServer -m -s /bin/bash gitServer $ passwd gitServer Configurer Git $ git config --global user.name \"gitServer\" $ git config --global user.email \"gitServer@gmail.com\" Cr\u00e9er un repertoire project.git: $ mkdir project.git $ cd project.git $ git config --list $ git --bare init","title":"6.2.1 Cr\u00e9ation de gitServer"},{"location":"articles/git/#622-creation-de-lutilisateur-tom","text":"Cr\u00e9ation de l'utilisateur Tom: $ sudo useradd -d /home/gitServer -m -s /bin/bash tom $ passwd tom Configurer Git pour Tom $ git config --global user.name \"tom\" $ git config --global user.email \"tom@gmail.com","title":"6.2.2 Cr\u00e9ation de l'utilisateur Tom"},{"location":"articles/git/#623-creation-de-lutilisateur-jerry","text":"Cr\u00e9ation de l'utilisateur Jerry: $ sudo useradd -d /home/jerry -m -s /bin/bash jerry $ passwd jerry Configurer Git pour Jerry $ git config --global user.name \"jerry\" $ git config --global user.email \"jerry@gmail.com","title":"6.2.3 Cr\u00e9ation de l'utilisateur Jerry"},{"location":"articles/git/#63-generation-des-cles-rsa-key-pair","text":"Pour gitServer: $ ssh-keygen Recuperer l'adresse l'IP $ ifconfig Pour Tom: $ ssh-keygen $ ssh-copy-id -i ~/.ssh/id_rsa.pub gitServe@ip_adress Pour Jerry: $ ssh-keygen $ ssh-copy-id -i ~/.ssh/id_rsa.pub gitServe@ip_adress","title":"6.3 G\u00e9n\u00e9ration des cl\u00e8s (RSA Key pair)"},{"location":"articles/git/#64-developpement-de-la-bibliotheque","text":"Tom cr\u00e9e un repository local Se placer dans le repertoire de Tom: $ su tom $ pwd Cr\u00e9er le repertoire tom_repo pour le projet $ mkdir tom_repo $ cd tom_repo D\u00e9clarer le repertoire comme \u00e9tant un depot git $ pwd $ git init Ajouter un fichier README.md qui d\u00e9crit le projet $ touch README.md Verifier le status $ git status -s Ajouter le fichier README.md au staging area $ git add README.md $ git status -s Ajouter le fichier README au depot git $ git commit -m \"Ajout de README\" $ git status -s Relier le dep\u00f4t local au depot distant project.git qui se trouve dans le server gitServer: $ git remote add origin gitServer@ip_address:project Envoyer vers le server $ git push origin master Jerry clone le repo et cr\u00e9e le fichier strings.c clone le repo se trouvant sur gitServer $ git clone gitServer@ip_address:project $ cd project consulte le repo $ ls $ git log $ git status -s Ajoute un fichier strings.c $ nano strings.c $ git status -s Ajouter le fichier au staging Area $ git add strings.c $ git status -s Faire un commit $ git commit -m \"Ajout du fichier strings.c\" $ git status -s Envoyer au server git push origin master Tom clone le repo pour modifier README et consulter les changements effectu\u00e9s par Jerry clone le repository $ git clone gitServer@ip_adress:project $ cd project consulte les modifications $ git log Modifie la description du projet $ nano README.md $ git add README.md $ git commit -m \"Modification du fichier README.md\" Envoyer au server $ git push origin master","title":"6.4 D\u00e9veloppement de la biblioth\u00e8que"},{"location":"computer_vision/cv/","text":"Vision par ordinateur Image formation Image sensing Digital Image What is an image Image format and difference Image Processing algorithms Edge Detection Boundary detection Image classification Object detection Object tracking","title":"Introduction"},{"location":"computer_vision/cv/#vision-par-ordinateur","text":"","title":"Vision par ordinateur"},{"location":"computer_vision/cv/#image-formation","text":"","title":"Image formation"},{"location":"computer_vision/cv/#image-sensing","text":"","title":"Image sensing"},{"location":"computer_vision/cv/#digital-image","text":"","title":"Digital Image"},{"location":"computer_vision/cv/#what-is-an-image","text":"","title":"What is an image"},{"location":"computer_vision/cv/#image-format-and-difference","text":"","title":"Image format and difference"},{"location":"computer_vision/cv/#image-processing-algorithms","text":"","title":"Image Processing algorithms"},{"location":"computer_vision/cv/#edge-detection","text":"","title":"Edge Detection"},{"location":"computer_vision/cv/#boundary-detection","text":"","title":"Boundary detection"},{"location":"computer_vision/cv/#image-classification","text":"","title":"Image classification"},{"location":"computer_vision/cv/#object-detection","text":"","title":"Object detection"},{"location":"computer_vision/cv/#object-tracking","text":"","title":"Object tracking"},{"location":"computer_vision/fr_object_detection/","text":"Detection des objets 1. Qu'est-ce que la detection des objets La d\u00e9tection des objets est une t\u00e2che de la vision par ordinateur qui consiste \u00e0 identifier et localiser un ensemble d'objets pr\u00e9difinis dans une image. Le but de la detection des objets est de determiner, \u00e9tant donn\u00e9e une image la presence des objets appartenant \u00e0 un ensemble de classes pr\u00e9definies, dans le cas \u00e9cheant de donner la localisation et la categorie de chaque objet present dans l'image. Pour localiser un objet on peut utiliser des bounding boxes, le centre de l'objet etc. Les techniques d'intelligence artificielle, plus particuli\u00e8rement les r\u00e9seaux de neurones, ont permis des avanc\u00e9es considerables dans le domaine de la d\u00e9tection des objets. Les objets qui font l'interet d'une detection sont des objets tres structur\u00e9s (voitures, avions, chaises etc) ou articul\u00e9s tels que les humains, les animaux etc. On s'interesse tr\u00e8s rarement aux objets non structur\u00e9s tels que le ciel, les nuages, grass etc. 2. Interets et Applications La detection des objets est essentiel pour des t\u00e2ches complexes telles que la segmentation, la comprehension des sc\u00e8nes, le suivi d'objets, image captionning, detection d'\u00e9v\u00e9nements, et reconnaissance des activit\u00e9s. Les applicatons o\u00f9 la detection des objets est utilis\u00e9e sont nombreuses. On peut retenir: Robot vision Electromenager Securit\u00e9 et surveillance Autonomous driving human computer interaction content based image retrieval Intelligent video surveillance Augmented Reality 3. Les algorithmes de la detection des objets 3.1 Algorithm performance evaluation Le but de la detection des objets est de mettre en place des algorithmes qui sont d'une grande exactitude (high accurate) et d'une grande effacit\u00e9 (high efficiency). high accurate car les objets doit \u00eatre reconnu et localis\u00e9 avec une grande precision dans des images ou vid\u00e9os, avoir la capacit\u00e9 \u00e0 differencier plusieurs categories d'objets. High efficiency parce que la detection doit \u00eatre faite en temps r\u00e9el avec moins de ressources (temps, memoire, puissance de calcul). Les metriques d'evaluation de performance utilis\u00e9es : 3.2 Benchmark Datasets for object detection Les datasets jouent un r\u00f4le important dans l'evaluation de la perfomance d'un algorithm de detection d'objets. Elles permettent de comparer et de mesurer les performances des algorithmes. PLusieurs benchmark datasets existent pour la detection des objets. Parmi lesquels on a: ImageNet PASCAL VOC MS COCO DATASET Le processus de cr\u00e9ation de ces datasets est : Identifier les classes d'objets qui doivent constituer la dataset Collecter sur Internet les images Annoter les images collect\u00e9es suivant un format bien choisie (crowdsourcing strategies) 4. Detection avec YOLO 4.1 Introduction 4.2 concepts \u00e0 comprendre 4.3 Versions des YOLO Plusieurs versions de YOLO existent. Voici une chronologie des am\u00e9liorations: YOLO V1 : Utilise GoogleNet pour l'extraction des features Avantages: One-shot detection mechanism, real-time Inconvenients : Difficult\u00e9s \u00e0 detecter les petits objets et les objets avec un aspect ratio (w/h) inhabituel, erreur de localisation comparer \u00e0 certains algorithme de detection. YOLO V2 : Am\u00e9liorations: Utilisation des anchors boxes pour la localisation des objets Batch normalization dans les cnn High resolution classifier Utilise Darknet19 comme backbone Inconvenients YOLO V3 : Am\u00e9liorations Utilise Darknet53 binary cross entropy in loss calculations Use of logistic regression in predicting the \"objectness score\" for each bounding box Feature extraction at three different scales inspired by FPN Inconvenient: Amelioration de l'accuracy a eu impact sur inference speed YOLO V3 : Am\u00e9liorations: Utilise CSPDarknet53 Use of Mish and Leaky ReLU as Activation function Adoption of a path aggregation network in place of FPN Use of Spatial Pyramid Pooling as a plug-in module 4.4 Architecture de YOLO V3 4.5 Exemple detection avec YOLO 5. Conclusion 6. Ressources Computer Vision Foundation CVF","title":"Object Detection"},{"location":"computer_vision/fr_object_detection/#detection-des-objets","text":"","title":" Detection des objets"},{"location":"computer_vision/fr_object_detection/#1-quest-ce-que-la-detection-des-objets","text":"","title":"1. Qu'est-ce que la detection des objets "},{"location":"computer_vision/fr_object_detection/#2-interets-et-applications","text":"","title":"2. Interets et Applications"},{"location":"computer_vision/fr_object_detection/#3-les-algorithmes-de-la-detection-des-objets","text":"","title":"3. Les algorithmes de la detection des objets"},{"location":"computer_vision/fr_object_detection/#31-algorithm-performance-evaluation","text":"","title":" 3.1 Algorithm performance evaluation "},{"location":"computer_vision/fr_object_detection/#32-benchmark-datasets-for-object-detection","text":"","title":" 3.2 Benchmark Datasets for object detection"},{"location":"computer_vision/fr_object_detection/#4-detection-avec-yolo","text":"","title":"4. Detection avec YOLO"},{"location":"computer_vision/fr_object_detection/#41-introduction","text":"","title":"4.1  Introduction"},{"location":"computer_vision/fr_object_detection/#42-concepts-a-comprendre","text":"","title":"4.2 concepts \u00e0 comprendre"},{"location":"computer_vision/fr_object_detection/#43-versions-des-yolo","text":"","title":"4.3  Versions des YOLO"},{"location":"computer_vision/fr_object_detection/#44-architecture-de-yolo-v3","text":"","title":"4.4 Architecture de YOLO V3"},{"location":"computer_vision/fr_object_detection/#45-exemple-detection-avec-yolo","text":"","title":"4.5 Exemple detection avec YOLO"},{"location":"computer_vision/fr_object_detection/#5-conclusion","text":"","title":"5. Conclusion"},{"location":"computer_vision/fr_object_detection/#6-ressources","text":"","title":" 6. Ressources"},{"location":"computer_vision/object_detection/","text":"Detection des objets 1. Qu'est-ce que la detection des objets La d\u00e9tection des objets est une t\u00e2che de la vision par ordinateur qui consiste \u00e0 identifier et localiser un ensemble d'objets pr\u00e9difinis dans une image. The goal of object detection is to determine whether there are any instances of objects from given categories (such as humans, cars, bicycles, dogs or cats) in an image and, if present, to return the spatial location and extent of each object instance. Deep learning techniques has emerged as powerful methods for learning feature representations automatically from data. In particular, theses techniques have provided major improvements in object detection. Object detection can be grouped into one two types : detection of specific instances versus the detection of broad categories. The first type aims to detect instances of a particular object (such as Donald Trump's face, the Eiffel Tower, or a neighbor's dog), essentially a matching problem. The goal of the second type is to detect (usually previously unseen) instances of some predefined object categories (for example humans, cars, bicycles, and dogs). Although thousands of objects occupy the visual world in which we live, currently the research community is primarily interested in the localization of highly structured objects (e.g cars, faces, bicycles and airplanes) and articulaled objects (e.g humans, cows and horses) rather than unstuctured scenes (such as sky, grass, and cloud) The spatial location and extent of an object can be defined coarsely using a bounding box (an axis-aligned rectangle tightly bounding the object), a precise pixelwise segmentation mask, or a closed boundary. 2. Int\u1ebfrets et Applications As the cornerstone of image understanding and computer vision, object detection forms the basis for solving complex or high level vision tasks such as segmentation, scene understanding, object tracking, image captioning, event detection, and activity recognition. Object detection supports a wide range of applications, including robot vision, consumer electronics, security, autonomous driving, human computer interaction, content based image retrieval, intelligent video surveillance, and augmented reality. 3. Les algorithmes de la detection des objets 3.1 Algorithm performance evaluation The ideal of generic object detection is to develop a general purpose algorithm that achieves two competing goals of high quality/accuracy and high efficiency. High quality detection must accurately localize and recognize objects in images or video frames, such that the large variety of object categories in the rea world can be distinguished (i.e., high distinctiveness), and that object instances from the same category, subject to intra-class appearance variations, can be localized and recognized (i.e high robustness). High efficiency requires that the entire detection task runs in real time with acceptable memory and storage demands. 3.2 Benchmark Datasets for object detection Datasets have played a key role throughout the history of object recognition research, not only as a common ground for measuring and comparing the performance of competing algorithms, but also pushing the field towards increasingly complex and challenging problems. There are three steps to creating large-scale annotated datasets: determining the set of target object categories, collecting a diverse set of candidate images to represent the selected categories, collecting a diverse set of candidate images to represent the selected categories on the Internet, and annotating the collected images, typically crowdsourcing strategies. 4. Detection avec YOLO 4.1 Introduction 4.2 concepts \u00e0 comprendre 4.3 Versions des YOLO 4.4 Exemple detection avec YOLO 5. Conclusion 6. Ressources","title":"Object detection"},{"location":"computer_vision/object_detection/#detection-des-objets","text":"","title":" Detection des objets"},{"location":"computer_vision/object_detection/#1-quest-ce-que-la-detection-des-objets","text":"","title":"1. Qu'est-ce que la detection des objets "},{"location":"computer_vision/object_detection/#2-interets-et-applications","text":"","title":"2. Int\u1ebfrets et Applications"},{"location":"computer_vision/object_detection/#3-les-algorithmes-de-la-detection-des-objets","text":"","title":"3. Les algorithmes de la detection des objets"},{"location":"computer_vision/object_detection/#31-algorithm-performance-evaluation","text":"","title":" 3.1 Algorithm performance evaluation "},{"location":"computer_vision/object_detection/#32-benchmark-datasets-for-object-detection","text":"","title":" 3.2 Benchmark Datasets for object detection"},{"location":"computer_vision/object_detection/#4-detection-avec-yolo","text":"","title":"4. Detection avec YOLO"},{"location":"computer_vision/object_detection/#41-introduction","text":"","title":"4.1  Introduction"},{"location":"computer_vision/object_detection/#42-concepts-a-comprendre","text":"","title":"4.2 concepts \u00e0 comprendre"},{"location":"computer_vision/object_detection/#43-versions-des-yolo","text":"","title":"4.3  Versions des YOLO"},{"location":"computer_vision/object_detection/#44-exemple-detection-avec-yolo","text":"","title":"4.4 Exemple detection avec YOLO"},{"location":"computer_vision/object_detection/#5-conclusion","text":"","title":"5. Conclusion"},{"location":"computer_vision/object_detection/#6-ressources","text":"","title":" 6. Ressources"},{"location":"prog_lang/c_prog/","text":"Langage de programmation C 1. Introduction 2. Historique du Langage de programmation C Le langage C a \u00e9t\u00e9 con\u00e7u en 1972 par Dennis Ritchie et Ken Thompson (en ce temps chercheurs aux Bell Labs). Il a \u00e9t\u00e9 con\u00e7u dans le but de d\u00e9velopper le syst\u00e8me d'exploitation UNIX. En 1983 L'ANSI d\u00e9cide de normaliser le langage, ce qui a conduit \u00e0 la norme ANSI C en 1989. En 1990, cette m\u00eame norme fut reprise par l'ISO. La compilation et interpretation La compilation consiste \u00e0 traduire un code en un autre code \u00e9quivalent. les programmes charg\u00e9s de faire cela, sont app\u00e9l\u00e9s des compilateurs. L'interpretation: En C la compilation est faite en 4 phases (reference Programmation en langage C de Anne CANTEAUT): Le traitement par le pr\u00e9processeur : le fichier source est analys\u00e9 par le pr\u00e9processeur qui effectue des transformations purement textuelles (remplacement de cha\u0131\u0302nes de caract\u00e8res, inclusion d\u2019autres fichiers source . . . ). La compilation : la compilation proprement dite traduit le fichier g\u00e9n\u00e9r\u00e9 par le pr\u00e9processeur en assembleur, c\u2019est-\u00e0-dire en une suite d\u2019instructions du microprocesseur qui utilisent des mn\u00e9moniques rendant la lecture possible. L\u2019assemblage : cette op\u00e9ration transforme le code assembleur en un fichier binaire, c\u2019est-\u00e0-dire en instructions directement compr\u00e9hensibles par le processeur. G\u00e9n\u00e9ralement, la compilation et l\u2019assemblage se font dans la foul\u00e9e, sauf si l\u2019on sp\u00e9cifie explicitement que l\u2019on veut le code assembleur. Le fichier produit par l\u2019assemblage est appel\u00e9 fichier objet. L\u2019\u00e9dition de liens : un programme est souvent s\u00e9par\u00e9 en plusieurs fichiers source, pour des raisons de clart\u00e9 mais aussi parce qu\u2019il fait g\u00e9n\u00e9ralement appel \u00e0 des librairies de fonctions standard d\u00e9j\u00e0 \u00e9crites. Une fois chaque code source assembl\u00e9, il faut donc lier entre eux les diff\u00e9rents fichiers objets. L\u2019\u00e9dition de liens produit alors un fichier dit ex\u00e9cutable. Les diff\u00e9rents types de fichiers utilis\u00e9s lors de la compilation sont distingu\u00e9s par leur suffixe. Les fichiers source sont suffix\u00e9s par .c, les fichiers pr\u00e9trait\u00e9s par le pr\u00e9processeur par .i, les fichiers assembleur par .s, et les fichiers objet par .o. Les fichiers correspondant aux librairies pr\u00e9-compil\u00e9s ont pour suffixe .a. Les compilateurs disponibles pour le langage: gcc du projet GNU (utilise ici comme compilateur) 3. Bases de la programmation C 3.1 Les composants \u00e9l\u00e9mentaires du C Tout programme C est constitu\u00e9 par les composants \u00e9l\u00e9mentaires. Les identificateurs : Ils permettent de nommer et d'identifier un objet manipul\u00e9 par le programme. Ces objets de programmation sont : les variables de tout type (types simples ou types compos\u00e9s), les fonctions. Le premier caract\u00e8re d'un identificateur ne doit \u00eatre ni un chiffre, ni un caract\u00e8re sp\u00e9cial (%, #, ? * etc). La limite du nombre de caract\u00e8re que peut comporter un identificateur d\u00e9pend des impl\u00e9mentations, mais elle est toujours sup\u00e9rieur \u00e0 31 caract\u00e8res. Les mots-cl\u00e8s : Ce sont des mots reserv\u00e9s au langage. Ils constituent en quelque sorte le vocabulaire du langage. Ils ne peuvent pas \u00eatre utilis\u00e9 comme identificateurs. (nom propre vs vocabulaire fran\u00e7ais). Les commentaires : Les commentaires sur une ligne: // Les commentaires sur plusieurs: /**/ Les constantes Les cha\u00eenes de caract\u00e8res Les op\u00e9rateurs Les signes de ponctuation 3.2 Structure d'un programme Le programme se structure comme suit: Les directives au pr\u00e9processeur Les d\u00e9clarations des variables globales Les fonctions s\u00e9condaires La fonction main 3.3 Les types en C En c on distingue plusieurs types: les entiers, les flottants, les caract\u00e8res: 3.3.1 Les entiers Les entiers constituent ce qu'on appelle en mathematiques les nombres relatifs. Donc un entier, est tout nombre appartenant \u00e0 l'ensemble Z dans la mesure du possible. Comme la machine est limit\u00e9e en terme de m\u00e9moire, donc on ne peut representer un entier qu'avec un nombre de bits limit\u00e9s. Le nombre de bits utilis\u00e9 pour representer un entier depend de l'implementation (de la machine). En C, suivant le nombre de bits utilis\u00e9s pour representer un entier, on distingue: int : entier represent\u00e9s sur 4 octets sur intel 64 bits short : entier represent\u00e9s sur 2 octets sur intel 64 bits long int : entier represent\u00e9s sur 8 octets sur intel 64 bits Pour representer un entier sign\u00e9: nombre positif: le premier bit correspond au signe, ici pour un nombre positif c'est 0. nombre negatif: pour representer un nombre negatif, la representation en complement en 2 est utilis\u00e9e. Representation d'un nombre non sign\u00e9: representation binaire tout le nombre de bits. 3.3.2 Les flottants 3.3.3 Les caract\u00e8res 3.2. Autres 3.3. Les op\u00e9rateurs 3.3.1 Les op\u00e9rateurs arithm\u00e9tiques 3.3.2 Les op\u00e9rateurs relationnnels 3.3.3 Les op\u00e9rateurs logiques 3.3.4 Les op\u00e9rateurs \u00e9tendus 3.3.5 Les op\u00e9rateurs bitwise 3.4 Les structures de contr\u00f4le 3.5 Les fonctions d'entr\u00e9es-sorties classiques 4. Les types compos\u00e9s 4.1 Les tableaux 4.2 Les structures 4.3 Les enumerations 4.4 Les unions 5. Les pointeurs 5.1 Introduction 5.2 Arithm\u00e9tique des pointeurs 6. Les fonctions Les fonctions permettent de : Reduire la duplication de code D\u00e9composer une t\u00e2che complexe en des petites t\u00e2ches Rendre le code plus lisible, facile \u00e0 tester, et r\u00e9utisable Cacher les d\u00e9tails de l'implementation 7. Les directives au pr\u00e9processeur 8. Les fichiers en C 9. La programmation modulaire 10. La librairie standard 11. Autres 11.1 Automation tools : Makefile 11.2 Debugger: GDB 11.3 Profiler: 11.4 Linter: 11.5 gcc: 12. Ressources The C programming language","title":"C programming"},{"location":"prog_lang/c_prog/#langage-de-programmation-c","text":"","title":" Langage de programmation C "},{"location":"prog_lang/c_prog/#1-introduction","text":"","title":"1. Introduction"},{"location":"prog_lang/c_prog/#2-historique-du-langage-de-programmation-c","text":"Le langage C a \u00e9t\u00e9 con\u00e7u en 1972 par Dennis Ritchie et Ken Thompson (en ce temps chercheurs aux Bell Labs). Il a \u00e9t\u00e9 con\u00e7u dans le but de d\u00e9velopper le syst\u00e8me d'exploitation UNIX. En 1983 L'ANSI d\u00e9cide de normaliser le langage, ce qui a conduit \u00e0 la norme ANSI C en 1989. En 1990, cette m\u00eame norme fut reprise par l'ISO.","title":"2. Historique du Langage de programmation C"},{"location":"prog_lang/c_prog/#la-compilation-et-interpretation","text":"La compilation consiste \u00e0 traduire un code en un autre code \u00e9quivalent. les programmes charg\u00e9s de faire cela, sont app\u00e9l\u00e9s des compilateurs. L'interpretation: En C la compilation est faite en 4 phases (reference Programmation en langage C de Anne CANTEAUT): Le traitement par le pr\u00e9processeur : le fichier source est analys\u00e9 par le pr\u00e9processeur qui effectue des transformations purement textuelles (remplacement de cha\u0131\u0302nes de caract\u00e8res, inclusion d\u2019autres fichiers source . . . ). La compilation : la compilation proprement dite traduit le fichier g\u00e9n\u00e9r\u00e9 par le pr\u00e9processeur en assembleur, c\u2019est-\u00e0-dire en une suite d\u2019instructions du microprocesseur qui utilisent des mn\u00e9moniques rendant la lecture possible. L\u2019assemblage : cette op\u00e9ration transforme le code assembleur en un fichier binaire, c\u2019est-\u00e0-dire en instructions directement compr\u00e9hensibles par le processeur. G\u00e9n\u00e9ralement, la compilation et l\u2019assemblage se font dans la foul\u00e9e, sauf si l\u2019on sp\u00e9cifie explicitement que l\u2019on veut le code assembleur. Le fichier produit par l\u2019assemblage est appel\u00e9 fichier objet. L\u2019\u00e9dition de liens : un programme est souvent s\u00e9par\u00e9 en plusieurs fichiers source, pour des raisons de clart\u00e9 mais aussi parce qu\u2019il fait g\u00e9n\u00e9ralement appel \u00e0 des librairies de fonctions standard d\u00e9j\u00e0 \u00e9crites. Une fois chaque code source assembl\u00e9, il faut donc lier entre eux les diff\u00e9rents fichiers objets. L\u2019\u00e9dition de liens produit alors un fichier dit ex\u00e9cutable. Les diff\u00e9rents types de fichiers utilis\u00e9s lors de la compilation sont distingu\u00e9s par leur suffixe. Les fichiers source sont suffix\u00e9s par .c, les fichiers pr\u00e9trait\u00e9s par le pr\u00e9processeur par .i, les fichiers assembleur par .s, et les fichiers objet par .o. Les fichiers correspondant aux librairies pr\u00e9-compil\u00e9s ont pour suffixe .a. Les compilateurs disponibles pour le langage: gcc du projet GNU (utilise ici comme compilateur)","title":"La compilation et interpretation"},{"location":"prog_lang/c_prog/#3-bases-de-la-programmation-c","text":"","title":"3. Bases de la programmation C"},{"location":"prog_lang/c_prog/#31-les-composants-elementaires-du-c","text":"Tout programme C est constitu\u00e9 par les composants \u00e9l\u00e9mentaires. Les identificateurs : Ils permettent de nommer et d'identifier un objet manipul\u00e9 par le programme. Ces objets de programmation sont : les variables de tout type (types simples ou types compos\u00e9s), les fonctions. Le premier caract\u00e8re d'un identificateur ne doit \u00eatre ni un chiffre, ni un caract\u00e8re sp\u00e9cial (%, #, ? * etc). La limite du nombre de caract\u00e8re que peut comporter un identificateur d\u00e9pend des impl\u00e9mentations, mais elle est toujours sup\u00e9rieur \u00e0 31 caract\u00e8res. Les mots-cl\u00e8s : Ce sont des mots reserv\u00e9s au langage. Ils constituent en quelque sorte le vocabulaire du langage. Ils ne peuvent pas \u00eatre utilis\u00e9 comme identificateurs. (nom propre vs vocabulaire fran\u00e7ais). Les commentaires : Les commentaires sur une ligne: // Les commentaires sur plusieurs: /**/ Les constantes Les cha\u00eenes de caract\u00e8res Les op\u00e9rateurs Les signes de ponctuation","title":"3.1 Les composants \u00e9l\u00e9mentaires du C"},{"location":"prog_lang/c_prog/#32-structure-dun-programme","text":"Le programme se structure comme suit: Les directives au pr\u00e9processeur Les d\u00e9clarations des variables globales Les fonctions s\u00e9condaires La fonction main","title":"3.2 Structure d'un programme"},{"location":"prog_lang/c_prog/#33-les-types-en-c","text":"En c on distingue plusieurs types: les entiers, les flottants, les caract\u00e8res:","title":"3.3 Les types en C"},{"location":"prog_lang/c_prog/#331-les-entiers","text":"Les entiers constituent ce qu'on appelle en mathematiques les nombres relatifs. Donc un entier, est tout nombre appartenant \u00e0 l'ensemble Z dans la mesure du possible. Comme la machine est limit\u00e9e en terme de m\u00e9moire, donc on ne peut representer un entier qu'avec un nombre de bits limit\u00e9s. Le nombre de bits utilis\u00e9 pour representer un entier depend de l'implementation (de la machine). En C, suivant le nombre de bits utilis\u00e9s pour representer un entier, on distingue: int : entier represent\u00e9s sur 4 octets sur intel 64 bits short : entier represent\u00e9s sur 2 octets sur intel 64 bits long int : entier represent\u00e9s sur 8 octets sur intel 64 bits Pour representer un entier sign\u00e9: nombre positif: le premier bit correspond au signe, ici pour un nombre positif c'est 0. nombre negatif: pour representer un nombre negatif, la representation en complement en 2 est utilis\u00e9e. Representation d'un nombre non sign\u00e9: representation binaire tout le nombre de bits.","title":"3.3.1 Les entiers"},{"location":"prog_lang/c_prog/#332-les-flottants","text":"","title":"3.3.2 Les flottants"},{"location":"prog_lang/c_prog/#333-les-caracteres","text":"","title":"3.3.3 Les caract\u00e8res"},{"location":"prog_lang/c_prog/#32-autres","text":"","title":"3.2. Autres"},{"location":"prog_lang/c_prog/#33-les-operateurs","text":"","title":"3.3. Les op\u00e9rateurs"},{"location":"prog_lang/c_prog/#331-les-operateurs-arithmetiques","text":"","title":"3.3.1 Les op\u00e9rateurs arithm\u00e9tiques"},{"location":"prog_lang/c_prog/#332-les-operateurs-relationnnels","text":"","title":"3.3.2 Les op\u00e9rateurs relationnnels"},{"location":"prog_lang/c_prog/#333-les-operateurs-logiques","text":"","title":"3.3.3 Les op\u00e9rateurs logiques"},{"location":"prog_lang/c_prog/#334-les-operateurs-etendus","text":"","title":"3.3.4 Les op\u00e9rateurs \u00e9tendus"},{"location":"prog_lang/c_prog/#335-les-operateurs-bitwise","text":"","title":"3.3.5 Les op\u00e9rateurs bitwise"},{"location":"prog_lang/c_prog/#34-les-structures-de-controle","text":"","title":"3.4 Les structures de contr\u00f4le"},{"location":"prog_lang/c_prog/#35-les-fonctions-dentrees-sorties-classiques","text":"","title":"3.5 Les fonctions d'entr\u00e9es-sorties classiques"},{"location":"prog_lang/c_prog/#4-les-types-composes","text":"","title":"4. Les types compos\u00e9s"},{"location":"prog_lang/c_prog/#41-les-tableaux","text":"","title":"4.1 Les tableaux"},{"location":"prog_lang/c_prog/#42-les-structures","text":"","title":"4.2 Les structures"},{"location":"prog_lang/c_prog/#43-les-enumerations","text":"","title":"4.3 Les enumerations"},{"location":"prog_lang/c_prog/#44-les-unions","text":"","title":"4.4 Les unions"},{"location":"prog_lang/c_prog/#5-les-pointeurs","text":"","title":"5. Les pointeurs"},{"location":"prog_lang/c_prog/#51-introduction","text":"","title":"5.1 Introduction"},{"location":"prog_lang/c_prog/#52-arithmetique-des-pointeurs","text":"","title":"5.2 Arithm\u00e9tique des pointeurs"},{"location":"prog_lang/c_prog/#6-les-fonctions","text":"Les fonctions permettent de : Reduire la duplication de code D\u00e9composer une t\u00e2che complexe en des petites t\u00e2ches Rendre le code plus lisible, facile \u00e0 tester, et r\u00e9utisable Cacher les d\u00e9tails de l'implementation","title":"6. Les fonctions"},{"location":"prog_lang/c_prog/#7-les-directives-au-preprocesseur","text":"","title":"7. Les directives au pr\u00e9processeur"},{"location":"prog_lang/c_prog/#8-les-fichiers-en-c","text":"","title":"8. Les fichiers en C"},{"location":"prog_lang/c_prog/#9-la-programmation-modulaire","text":"","title":"9. La programmation modulaire"},{"location":"prog_lang/c_prog/#10-la-librairie-standard","text":"","title":"10. La librairie standard"},{"location":"prog_lang/c_prog/#11-autres","text":"","title":"11. Autres"},{"location":"prog_lang/c_prog/#111-automation-tools-makefile","text":"","title":"11.1 Automation tools : Makefile"},{"location":"prog_lang/c_prog/#112-debugger-gdb","text":"","title":"11.2 Debugger: GDB"},{"location":"prog_lang/c_prog/#113-profiler","text":"","title":"11.3 Profiler:"},{"location":"prog_lang/c_prog/#114-linter","text":"","title":"11.4 Linter:"},{"location":"prog_lang/c_prog/#115-gcc","text":"","title":"11.5 gcc:"},{"location":"prog_lang/c_prog/#12-ressources","text":"The C programming language","title":"12. Ressources"},{"location":"prog_lang/cpp_lang/","text":"","title":"Cpp lang"},{"location":"prog_lang/learning_python_practices/","text":"Python programming 1. Print Python Interpreter Version import sys print(sys.version) 3.8.5 (default, Sep 4 2020, 07:30:14) [GCC 7.3.0] 2. The zen of Python import this The Zen of Python, by Tim Peters Beautiful is better than ugly. Explicit is better than implicit. Simple is better than complex. Complex is better than complicated. Flat is better than nested. Sparse is better than dense. Readability counts. Special cases aren't special enough to break the rules. Although practicality beats purity. Errors should never pass silently. Unless explicitly silenced. In the face of ambiguity, refuse the temptation to guess. There should be one-- and preferably only one --obvious way to do it. Although that way may not be obvious at first unless you're Dutch. Now is better than never. Although never is often better than *right* now. If the implementation is hard to explain, it's a bad idea. If the implementation is easy to explain, it may be a good idea. Namespaces are one honking great idea -- let's do more of those! 3. Immutable and mutable objects ? age = 15 print('id_1: ', id(age)) age = 24 print('id_2: ', id(age)) id_1: 93847468392192 id_2: 93847468392480 An object is said to be immutable. When its value can be changed. Here, changing the age value result in creating new object. # Person class declaration class Person(): def __init__(self, name, age): self.name = name self.age = age p = Person('Abari', 24) print('Person P id : ', id(p)) print('age id : ', id(p.age)) p.age = 25 print('Person P id : ', id(p)) print('age id : ', id(p.age)) Person P id : 140461205741920 age id : 93847468392480 Person P id : 140461205741920 age id : 93847468392512 An object is said to mutable, when its value can be changed, without affecting its id. Custom are mutable (but you can make them immutable) 4. Numbers Numbers are immutables objects in Python 4.1 Integers # Integers a = 3 b = 2 # Addition print('Addition: ', a + b) # Substraction print('Substraction: ', a - b) # Multiplication print('Multiplication: ', a * b) # True division print('True division: ', a / b) # Integer division print('Integer division', a // b) # Modulo operation (reminder of a division) print('Modulo division: ', a % b) # Power Division print('Power operation: ', a ** b) # Division with negative number a = -3 b = 2 print('True Division: ', a / b) print('Integer Division: ', a // b) # Retain print('1- Python integers have an unlimited range, subject only to the available virtual memory') print('2- Integer division in Python is always rounded toward minus infinity') print('3- Truncation towards zero is done with the built-i int function') Addition: 5 Substraction: 1 Multiplication: 6 True division: 1.5 Integer division 1 Modulo division: 1 Power operation: 9 True Division: -1.5 Integer Division: -2 1- Python integers have an unlimited range, subject only to the available virtual memory 2- Integer division in Python is always rounded toward minus infinity 3- Truncation towards zero is done with the built-i int function n = 1_024 print(n) hex_n = 0x_4_0_0 print(hex_n) 1024 1024 4.2. Booleans int(True) 1 int(False) 0 bool(1) True bool(0) False bool(123) True bool(-23) True 1 + True 2 False + 42 42 7 - True 6 4.3. Real numbers pi = 3.1415926536 radius = 4.5 area = pi * (radius ** 2) print(area) 63.617251235400005 import sys print(sys.float_info) sys.float_info(max=1.7976931348623157e+308, max_exp=1024, max_10_exp=308, min=2.2250738585072014e-308, min_exp=-1021, min_10_exp=-307, dig=15, mant_dig=53, epsilon=2.220446049250313e-16, radix=2, rounds=1) 0.3 - 0.1 * 3 -5.551115123125783e-17 4.4. Complex numbers c = 3.14 + 2.73j print(c) (3.14+2.73j) c = complex(3.14, 2.73) print(c) (3.14+2.73j) type(c) complex c.real 3.14 c.imag 2.73 c.conjugate() (3.14-2.73j) c * 2 (6.28+5.46j) c ** 2 (2.4067000000000007+17.1444j) d = 1 + 1j c - d (2.14+1.73j) 4.5. Fractions and Decimals from fractions import Fraction f = Fraction(10, 6) print(f) 5/3 type(f) fractions.Fraction f.numerator 5 f.denominator 3 i = f.as_integer_ratio() print(i) print(type(i)) (5, 3) <class 'tuple'> from decimal import Decimal as D D(3.14) Decimal('3.140000000000000124344978758017532527446746826171875') D('3.14') Decimal('3.14') D(0.1) * D(3) - D(0.3) Decimal('2.775557561565156540423631668E-17') D('0.1') * D(3) - D('0.3') Decimal('0.0') D('1.4').as_integer_ratio() (7, 5) 5. Immutable sequences 5.1 Strings and bytes str1 = 'This is a string. We built it with single quotes' str2 = \"This is also a string, but built with double quotes\" str3 = '''This is built using triple quotes, so it can span multiple lines.''' str4 = \"\"\"This too is a multiline one built with triple double-quotes\"\"\" str4 'This too\\nis a multiline one\\nbuilt with triple double-quotes' print(str4) This too is a multiline one built with triple double-quotes str4_1 = repr(str4) print(str4_1) 'This too\\nis a multiline one\\nbuilt with triple double-quotes' str4_1 \"'This too\\\\nis a multiline one\\\\nbuilt with triple double-quotes'\" str4_2 = str(str4) print(str4_2) This too is a multiline one built with triple double-quotes str4_2 'This too\\nis a multiline one\\nbuilt with triple double-quotes' help(repr) Help on built-in function repr in module builtins: repr(obj, /) Return the canonical string representation of the object. For many object types, including most builtins, eval(repr(obj)) == obj. help(str) Help on class str in module builtins: class str(object) | str(object='') -> str | str(bytes_or_buffer[, encoding[, errors]]) -> str | | Create a new string object from the given object. If encoding or | errors is specified, then the object must expose a data buffer | that will be decoded using the given encoding and error handler. | Otherwise, returns the result of object.__str__() (if defined) | or repr(object). | encoding defaults to sys.getdefaultencoding(). | errors defaults to 'strict'. | | Methods defined here: | | __add__(self, value, /) | Return self+value. | | __contains__(self, key, /) | Return key in self. | | __eq__(self, value, /) | Return self==value. | | __format__(self, format_spec, /) | Return a formatted version of the string as described by format_spec. | | __ge__(self, value, /) | Return self>=value. | | __getattribute__(self, name, /) | Return getattr(self, name). | | __getitem__(self, key, /) | Return self[key]. | | __getnewargs__(...) | | __gt__(self, value, /) | Return self>value. | | __hash__(self, /) | Return hash(self). | | __iter__(self, /) | Implement iter(self). | | __le__(self, value, /) | Return self<=value. | | __len__(self, /) | Return len(self). | | __lt__(self, value, /) | Return self<value. | | __mod__(self, value, /) | Return self%value. | | __mul__(self, value, /) | Return self*value. | | __ne__(self, value, /) | Return self!=value. | | __repr__(self, /) | Return repr(self). | | __rmod__(self, value, /) | Return value%self. | | __rmul__(self, value, /) | Return value*self. | | __sizeof__(self, /) | Return the size of the string in memory, in bytes. | | __str__(self, /) | Return str(self). | | capitalize(self, /) | Return a capitalized version of the string. | | More specifically, make the first character have upper case and the rest lower | case. | | casefold(self, /) | Return a version of the string suitable for caseless comparisons. | | center(self, width, fillchar=' ', /) | Return a centered string of length width. | | Padding is done using the specified fill character (default is a space). | | count(...) | S.count(sub[, start[, end]]) -> int | | Return the number of non-overlapping occurrences of substring sub in | string S[start:end]. Optional arguments start and end are | interpreted as in slice notation. | | encode(self, /, encoding='utf-8', errors='strict') | Encode the string using the codec registered for encoding. | | encoding | The encoding in which to encode the string. | errors | The error handling scheme to use for encoding errors. | The default is 'strict' meaning that encoding errors raise a | UnicodeEncodeError. Other possible values are 'ignore', 'replace' and | 'xmlcharrefreplace' as well as any other name registered with | codecs.register_error that can handle UnicodeEncodeErrors. | | endswith(...) | S.endswith(suffix[, start[, end]]) -> bool | | Return True if S ends with the specified suffix, False otherwise. | With optional start, test S beginning at that position. | With optional end, stop comparing S at that position. | suffix can also be a tuple of strings to try. | | expandtabs(self, /, tabsize=8) | Return a copy where all tab characters are expanded using spaces. | | If tabsize is not given, a tab size of 8 characters is assumed. | | find(...) | S.find(sub[, start[, end]]) -> int | | Return the lowest index in S where substring sub is found, | such that sub is contained within S[start:end]. Optional | arguments start and end are interpreted as in slice notation. | | Return -1 on failure. | | format(...) | S.format(*args, **kwargs) -> str | | Return a formatted version of S, using substitutions from args and kwargs. | The substitutions are identified by braces ('{' and '}'). | | format_map(...) | S.format_map(mapping) -> str | | Return a formatted version of S, using substitutions from mapping. | The substitutions are identified by braces ('{' and '}'). | | index(...) | S.index(sub[, start[, end]]) -> int | | Return the lowest index in S where substring sub is found, | such that sub is contained within S[start:end]. Optional | arguments start and end are interpreted as in slice notation. | | Raises ValueError when the substring is not found. | | isalnum(self, /) | Return True if the string is an alpha-numeric string, False otherwise. | | A string is alpha-numeric if all characters in the string are alpha-numeric and | there is at least one character in the string. | | isalpha(self, /) | Return True if the string is an alphabetic string, False otherwise. | | A string is alphabetic if all characters in the string are alphabetic and there | is at least one character in the string. | | isascii(self, /) | Return True if all characters in the string are ASCII, False otherwise. | | ASCII characters have code points in the range U+0000-U+007F. | Empty string is ASCII too. | | isdecimal(self, /) | Return True if the string is a decimal string, False otherwise. | | A string is a decimal string if all characters in the string are decimal and | there is at least one character in the string. | | isdigit(self, /) | Return True if the string is a digit string, False otherwise. | | A string is a digit string if all characters in the string are digits and there | is at least one character in the string. | | isidentifier(self, /) | Return True if the string is a valid Python identifier, False otherwise. | | Call keyword.iskeyword(s) to test whether string s is a reserved identifier, | such as \"def\" or \"class\". | | islower(self, /) | Return True if the string is a lowercase string, False otherwise. | | A string is lowercase if all cased characters in the string are lowercase and | there is at least one cased character in the string. | | isnumeric(self, /) | Return True if the string is a numeric string, False otherwise. | | A string is numeric if all characters in the string are numeric and there is at | least one character in the string. | | isprintable(self, /) | Return True if the string is printable, False otherwise. | | A string is printable if all of its characters are considered printable in | repr() or if it is empty. | | isspace(self, /) | Return True if the string is a whitespace string, False otherwise. | | A string is whitespace if all characters in the string are whitespace and there | is at least one character in the string. | | istitle(self, /) | Return True if the string is a title-cased string, False otherwise. | | In a title-cased string, upper- and title-case characters may only | follow uncased characters and lowercase characters only cased ones. | | isupper(self, /) | Return True if the string is an uppercase string, False otherwise. | | A string is uppercase if all cased characters in the string are uppercase and | there is at least one cased character in the string. | | join(self, iterable, /) | Concatenate any number of strings. | | The string whose method is called is inserted in between each given string. | The result is returned as a new string. | | Example: '.'.join(['ab', 'pq', 'rs']) -> 'ab.pq.rs' | | ljust(self, width, fillchar=' ', /) | Return a left-justified string of length width. | | Padding is done using the specified fill character (default is a space). | | lower(self, /) | Return a copy of the string converted to lowercase. | | lstrip(self, chars=None, /) | Return a copy of the string with leading whitespace removed. | | If chars is given and not None, remove characters in chars instead. | | partition(self, sep, /) | Partition the string into three parts using the given separator. | | This will search for the separator in the string. If the separator is found, | returns a 3-tuple containing the part before the separator, the separator | itself, and the part after it. | | If the separator is not found, returns a 3-tuple containing the original string | and two empty strings. | | replace(self, old, new, count=-1, /) | Return a copy with all occurrences of substring old replaced by new. | | count | Maximum number of occurrences to replace. | -1 (the default value) means replace all occurrences. | | If the optional argument count is given, only the first count occurrences are | replaced. | | rfind(...) | S.rfind(sub[, start[, end]]) -> int | | Return the highest index in S where substring sub is found, | such that sub is contained within S[start:end]. Optional | arguments start and end are interpreted as in slice notation. | | Return -1 on failure. | | rindex(...) | S.rindex(sub[, start[, end]]) -> int | | Return the highest index in S where substring sub is found, | such that sub is contained within S[start:end]. Optional | arguments start and end are interpreted as in slice notation. | | Raises ValueError when the substring is not found. | | rjust(self, width, fillchar=' ', /) | Return a right-justified string of length width. | | Padding is done using the specified fill character (default is a space). | | rpartition(self, sep, /) | Partition the string into three parts using the given separator. | | This will search for the separator in the string, starting at the end. If | the separator is found, returns a 3-tuple containing the part before the | separator, the separator itself, and the part after it. | | If the separator is not found, returns a 3-tuple containing two empty strings | and the original string. | | rsplit(self, /, sep=None, maxsplit=-1) | Return a list of the words in the string, using sep as the delimiter string. | | sep | The delimiter according which to split the string. | None (the default value) means split according to any whitespace, | and discard empty strings from the result. | maxsplit | Maximum number of splits to do. | -1 (the default value) means no limit. | | Splits are done starting at the end of the string and working to the front. | | rstrip(self, chars=None, /) | Return a copy of the string with trailing whitespace removed. | | If chars is given and not None, remove characters in chars instead. | | split(self, /, sep=None, maxsplit=-1) | Return a list of the words in the string, using sep as the delimiter string. | | sep | The delimiter according which to split the string. | None (the default value) means split according to any whitespace, | and discard empty strings from the result. | maxsplit | Maximum number of splits to do. | -1 (the default value) means no limit. | | splitlines(self, /, keepends=False) | Return a list of the lines in the string, breaking at line boundaries. | | Line breaks are not included in the resulting list unless keepends is given and | true. | | startswith(...) | S.startswith(prefix[, start[, end]]) -> bool | | Return True if S starts with the specified prefix, False otherwise. | With optional start, test S beginning at that position. | With optional end, stop comparing S at that position. | prefix can also be a tuple of strings to try. | | strip(self, chars=None, /) | Return a copy of the string with leading and trailing whitespace removed. | | If chars is given and not None, remove characters in chars instead. | | swapcase(self, /) | Convert uppercase characters to lowercase and lowercase characters to uppercase. | | title(self, /) | Return a version of the string where each word is titlecased. | | More specifically, words start with uppercased characters and all remaining | cased characters have lower case. | | translate(self, table, /) | Replace each character in the string using the given translation table. | | table | Translation table, which must be a mapping of Unicode ordinals to | Unicode ordinals, strings, or None. | | The table must implement lookup/indexing via __getitem__, for instance a | dictionary or list. If this operation raises LookupError, the character is | left untouched. Characters mapped to None are deleted. | | upper(self, /) | Return a copy of the string converted to uppercase. | | zfill(self, width, /) | Pad a numeric string with zeros on the left, to fill a field of the given width. | | The string is never truncated. | | ---------------------------------------------------------------------- | Static methods defined here: | | __new__(*args, **kwargs) from builtins.type | Create and return a new object. See help(type) for accurate signature. | | maketrans(...) | Return a translation table usable for str.translate(). | | If there is only one argument, it must be a dictionary mapping Unicode | ordinals (integers) or characters to Unicode ordinals, strings or None. | Character keys will be then converted to ordinals. | If there are two arguments, they must be strings of equal length, and | in the resulting dictionary, each character in x will be mapped to the | character at the same position in y. If there is a third argument, it | must be a string, whose characters will be mapped to None in the result. # Python >=3.9 s = 'Hello There' s.removeprefix('Hell') s.removesuffix('here') s.removeprefix('Ooops') --------------------------------------------------------------------------- AttributeError Traceback (most recent call last) <ipython-input-80-40b1b20ef836> in <module> 1 s = 'Hello There' ----> 2 s.removeprefix('Hell') 3 s.removesuffix('here') 4 s.removeprefix('Ooops') AttributeError: 'str' object has no attribute 'removeprefix' s = \"this is \u00e9l\u00e8ve\" type(s) str encoded_s = s.encode('utf-8') encoded_s b'this is \\xc3\\xa9l\\xc3\\xa8ve' type(encoded_s) bytes encoded_s.decode('utf-8') 'this is \u00e9l\u00e8ve' for b in encoded_s: print(f'{b} : {type(b)}') 116 : <class 'int'> 104 : <class 'int'> 105 : <class 'int'> 115 : <class 'int'> 32 : <class 'int'> 105 : <class 'int'> 115 : <class 'int'> 32 : <class 'int'> 195 : <class 'int'> 169 : <class 'int'> 108 : <class 'int'> 195 : <class 'int'> 168 : <class 'int'> 118 : <class 'int'> 101 : <class 'int'> your_mantra = \"The trouble is you think you have time\" your_mantra[0] 'T' your_mantra[5] 'r' your_mantra[:4] 'The ' your_mantra[4:] 'trouble is you think you have time' your_mantra[2:14] 'e trouble is' your_mantra[2:14:3] 'erb ' your_mantra[:] #Easy way to get copy of a string 'The trouble is you think you have time' your_mantra[-1::-1] #Reverse of a string from slicing 'emit evah uoy kniht uoy si elbuort ehT' # Deprecated greet_old = 'Hello %s!' greet_old % 'Fabrizio' 'Hello Fabrizio!' greet_positional = 'Hello {}!' greet_positional.format('Fabrizio') 'Hello Fabrizio!' greet_positional = 'Hello {} {}!' greet_positional.format('Abari', 'Kader') 'Hello Abari Kader!' greet_positional_idx = 'This is {0}! {1} is sister to {0}' greet_positional_idx.format('Hawa', 'Asmaou') 'This is Hawa! Asmaou is sister to Hawa' keyword = '{name} is student at {school}.' keyword.format(name='Abari', school='National School of Applied Sciences') 'Abari is student at National School of Applied Sciences.' name = 'Fab' age = 42 f\"Hello! My name is {name} and I'm {age}\" \"Hello! My name is Fab and I'm 42\" from math import pi f\"No arguing with {pi}, it's irrational\" \"No arguing with 3.141592653589793, it's irrational\" user = 'heinrich' password = 'super-secret' f\"Log in with:{user} and {password}\" 'Log in with:heinrich and super-secret' f\"Log in with:{user=} and {password=}\" \"Log in with:user='heinrich' and password='super-secret'\" 5.2 Tuples t = () type(t) tuple one_element_tuple = (32, ) three_elements_tuple = (1, 3, 5) a, b, c = 1, 2, 3 a, b, c (1, 2, 3) a, b = 1, 2 c = a a = b b = c print(a, b) 2 1 a, b = 3, 4 a, b = b, a print(a, b) 4 3 6. Mutable Sequences 6.1 Lists [] [] list() [] [1, 2, 3] [1, 2, 3] [x + 5 for x in [2, 3, 4]] [7, 8, 9] list('Hello') ['H', 'e', 'l', 'l', 'o'] a = [1, 2, 1, 3] a.append(13) print(a) [1, 2, 1, 3, 13] a.count(1) print(a) [1, 2, 1, 3, 13] a.extend([5, 7]) print(a) [1, 2, 1, 3, 13, 5, 7] a.index(13) print(a) [1, 2, 1, 3, 13, 5, 7] a.insert(0, 17) print(a) [17, 1, 2, 1, 3, 13, 5, 7] a.pop() 7 a.pop(3) 1 a [17, 1, 2, 3, 13, 5] a.sort() print(a) [1, 2, 3, 5, 13, 17] a.clear() print(a) [] a = [1, 3, 5, 7] min(a) 1 max(a) 7 sum(a) 16 from math import prod prod(a) 105 len(a) 4 b = [6, 7, 8] a + b [1, 3, 5, 7, 6, 7, 8] a * 2 [1, 3, 5, 7, 1, 3, 5, 7] from operator import itemgetter a = [(5, 3), (1, 3), (1, 2), (2, -1), (4, 9)] sorted(a) [(1, 2), (1, 3), (2, -1), (4, 9), (5, 3)] sorted(a, key=itemgetter(0, 1)) [(1, 2), (1, 3), (2, -1), (4, 9), (5, 3)] sorted(a, key=itemgetter(1)) [(2, -1), (1, 2), (5, 3), (1, 3), (4, 9)] sorted(a, key=itemgetter(1), reverse=True) [(4, 9), (5, 3), (1, 3), (1, 2), (2, -1)] 6.2 Bytearrays bytearray() bytearray(b'') b = bytearray(10) bytearray(range(5)) bytearray(b'\\x00\\x01\\x02\\x03\\x04') name = bytearray(b'Lina') name.replace(b'L', b'l') bytearray(b'lina') name.endswith(b'na') True name.upper() bytearray(b'LINA') name.count(b'L') 1 print(name) bytearray(b'Lina') name.decode('utf8') 'Lina' byte = bytearray([66, 65, 124, 123]) byte.decode('utf') 'BA|{' 7 Set types small_primes = set() small_primes.add(2) small_primes.add(3) small_primes.add(5) print(small_primes) {2, 3, 5} small_primes.add(1) print(small_primes) small_primes.remove(1) print(small_primes) {1, 2, 3, 5} {2, 3, 5} 3 in small_primes True 4 not in small_primes True small_primes.add(3) print(small_primes) {2, 3, 5} bigger_primes = set([5, 7, 11, 13]) small_primes | bigger_primes {2, 3, 5, 7, 11, 13} small_primes & bigger_primes {5} small_primes - bigger_primes {2, 3} small_primes = {2, 3, 5, 5, 3} small_primes {2, 3, 5} small_primes_2 = frozenset([2, 3, 5, 7]) bigger_primes_2 = frozenset([5, 7, 11]) small_primes_2.add(11) --------------------------------------------------------------------------- AttributeError Traceback (most recent call last) <ipython-input-140-f9612be082dd> in <module> ----> 1 small_primes_2.add(11) AttributeError: 'frozenset' object has no attribute 'add' small_primes_2.remove(2) --------------------------------------------------------------------------- AttributeError Traceback (most recent call last) <ipython-input-141-09c0bc2b75a9> in <module> ----> 1 small_primes_2.remove(2) AttributeError: 'frozenset' object has no attribute 'remove' small_primes_2 & bigger_primes_2 frozenset({5, 7}) small_primes_2 | bigger_primes_2 frozenset({2, 3, 5, 7, 11}) 8. Mapping types : dictionaries a = dict(A=1, Z=-1) b = {'A': 1, 'Z': -1} c = dict(zip(['A', 'Z'], [1, -1])) d = dict([('A', 1), ('Z', -1)]) e = dict({'Z': -1, 'A': 1}) a == b == c == d == e True list(zip('Hello', range(1, 6))) [('H', 1), ('e', 2), ('l', 3), ('l', 4), ('o', 5)] d = dict(zip('hello', range(5))) print(d) {'h': 0, 'e': 1, 'l': 3, 'o': 4} k = d.keys() v = d.values() items = d.items() 3 in d.values() True ('o', 4) in d.items() True d.popitem() ('o', 4) d.pop('l') 3 d.pop('not-a-key') --------------------------------------------------------------------------- KeyError Traceback (most recent call last) <ipython-input-166-79ca84a85bcf> in <module> ----> 1 d.pop('not-a-key') KeyError: 'not-a-key' d.pop('not-a-key', 'default-value') 'default-value' d.update({'another': 'value'}) d.update(a=13) d {'h': 0, 'e': 1, 'another': 'value', 'a': 13} d.get('a', 177) 13 d.get('b', 177) 177 d.get('b') d {'h': 0, 'e': 1, 'another': 'value', 'a': 13} d = {} d.setdefault('a', 1) 1 d {'a': 1} {'a': {'b': [1]}} {'a': {'b': [1]}} d = {} d.setdefault('a', {}).setdefault('b', []).append(1) d {'a': {'b': [1]}} 9. Dates and times from datetime import date, datetime, timedelta, timezone import time import calendar as cal #from zoneinfo import ZoneInfo today = date.today() type(today) datetime.date print(today) 2022-05-15 today.ctime() 'Sun May 15 00:00:00 2022' today.isoformat() '2022-05-15' today.weekday() 6 cal.day_name[today.weekday()] 'Sunday' today.day, today.month, today.year (15, 5, 2022) today.timetuple() time.struct_time(tm_year=2022, tm_mon=5, tm_mday=15, tm_hour=0, tm_min=0, tm_sec=0, tm_wday=6, tm_yday=135, tm_isdst=-1) time.ctime() 'Mon May 16 00:56:02 2022' time.daylight 0 time.gmtime() time.struct_time(tm_year=2022, tm_mon=5, tm_mday=15, tm_hour=23, tm_min=57, tm_sec=8, tm_wday=6, tm_yday=135, tm_isdst=0) time.gmtime(0) time.struct_time(tm_year=1970, tm_mon=1, tm_mday=1, tm_hour=0, tm_min=0, tm_sec=0, tm_wday=3, tm_yday=1, tm_isdst=0) time.localtime() time.struct_time(tm_year=2022, tm_mon=5, tm_mday=16, tm_hour=0, tm_min=57, tm_sec=56, tm_wday=0, tm_yday=136, tm_isdst=0) time.time() 1652659085.3439333 now = datetime.now() utcnow = datetime.utcnow() now datetime.datetime(2022, 5, 16, 1, 7, 43, 328210) utcnow datetime.datetime(2022, 5, 16, 0, 0, 31, 881436) now.date() datetime.date(2022, 5, 16) now.day, now.month, now.year (16, 5, 2022) now.date() == date.today() True now.time() datetime.time(1, 0, 20, 405250) now.hour, now.minute, now.second, now.microsecond (1, 0, 20, 405250) now.ctime() 'Mon May 16 01:07:43 2022' now.isoformat() '2022-05-16T01:07:43.328210' now.timetuple() time.struct_time(tm_year=2022, tm_mon=5, tm_mday=16, tm_hour=1, tm_min=0, tm_sec=20, tm_wday=0, tm_yday=136, tm_isdst=-1) now.tzinfo utcnow.tzinfo now.weekday() 0 f_bday = datetime(1997, 10, 5, 14, 5) f_bday.isoformat() '1997-10-05T14:05:00' h_bday = f_bday + timedelta(days=365) h_bday == datetime(1998, 10, 5, 14, 5) True 10. The collections module 10.1 Namedtuple vision = (9.5, 8.8) vision (9.5, 8.8) vision[0] 9.5 vision[1] 8.8 from collections import namedtuple Vision = namedtuple('Vision', ['left', 'right']) vision = Vision(9.5, 8.8) vision[0] 9.5 vision[1] 8.8 vision.left 9.5 vision.right 8.8 Vision = namedtuple('Vision', ['left', 'combined', 'right']) vision = Vision(9.5, 9.2, 8.8) vision.left 9.5 vision.right 8.8 vision.combined 9.2 10.2 defaultdict d = {} d['age'] = d.get('age', 0) + 1 d {'age': 1} d = {'age': 39} d['age'] = d.get('age', 0) + 1 d {'age': 40} from collections import defaultdict dd = defaultdict(int) dd['age'] +=1 dd['gpa'] += 4 dd defaultdict(int, {'age': 1, 'gpa': 4}) 10.3 ChainMap from collections import ChainMap default_connection = {'host': 'localhost', 'port': 4567} connection = {'port': 5678} conn = ChainMap(connection, default_connection) conn['port'] 5678 conn['host'] 'localhost' conn.maps [{'port': 5678}, {'host': 'localhost', 'port': 4567}] conn['host'] = 'packtpub.com' conn.maps [{'port': 5678, 'host': 'packtpub.com'}, {'host': 'localhost', 'port': 4567}] del conn['port'] conn.maps [{'host': 'packtpub.com'}, {'host': 'localhost', 'port': 4567}] conn['port'] 4567 dict(conn) {'host': 'packtpub.com', 'port': 4567} 10.4 Enums GREEN = 1 YELLOW = 2 RED = 4 TRAFFIC_LIGHTS = (GREEN, YELLOW, RED) traffic_lights = {'GREEN': 1, 'YELLOW': 2, 'RED': 4} from enum import Enum class TrafficLight(Enum): GREEN = 1 YELLOW = 2 RED = 4 TrafficLight.GREEN <TrafficLight.GREEN: 1> TrafficLight.GREEN.value 1 TrafficLight(4) <TrafficLight.RED: 4> 11. Small value caching a = 1000000 b = 1000000 id(a) == id(b) False a = 5 b = 5 id(a) == id(b) True a = 5 b = 6 id(a) == id(b) False a = 6 id(a) == id(b) True c = 6 id(a) == id(b) True Conditionals and Iteration","title":"Python programming"},{"location":"prog_lang/learning_python_practices/#python-programming","text":"","title":"Python programming"},{"location":"prog_lang/learning_python_practices/#1-print-python-interpreter-version","text":"import sys print(sys.version) 3.8.5 (default, Sep 4 2020, 07:30:14) [GCC 7.3.0]","title":"1. Print Python Interpreter Version"},{"location":"prog_lang/learning_python_practices/#2-the-zen-of-python","text":"import this The Zen of Python, by Tim Peters Beautiful is better than ugly. Explicit is better than implicit. Simple is better than complex. Complex is better than complicated. Flat is better than nested. Sparse is better than dense. Readability counts. Special cases aren't special enough to break the rules. Although practicality beats purity. Errors should never pass silently. Unless explicitly silenced. In the face of ambiguity, refuse the temptation to guess. There should be one-- and preferably only one --obvious way to do it. Although that way may not be obvious at first unless you're Dutch. Now is better than never. Although never is often better than *right* now. If the implementation is hard to explain, it's a bad idea. If the implementation is easy to explain, it may be a good idea. Namespaces are one honking great idea -- let's do more of those!","title":"2. The zen of Python"},{"location":"prog_lang/learning_python_practices/#3-immutable-and-mutable-objects","text":"age = 15 print('id_1: ', id(age)) age = 24 print('id_2: ', id(age)) id_1: 93847468392192 id_2: 93847468392480 An object is said to be immutable. When its value can be changed. Here, changing the age value result in creating new object. # Person class declaration class Person(): def __init__(self, name, age): self.name = name self.age = age p = Person('Abari', 24) print('Person P id : ', id(p)) print('age id : ', id(p.age)) p.age = 25 print('Person P id : ', id(p)) print('age id : ', id(p.age)) Person P id : 140461205741920 age id : 93847468392480 Person P id : 140461205741920 age id : 93847468392512 An object is said to mutable, when its value can be changed, without affecting its id. Custom are mutable (but you can make them immutable)","title":"3. Immutable and mutable objects ?"},{"location":"prog_lang/learning_python_practices/#4-numbers","text":"Numbers are immutables objects in Python","title":"4. Numbers"},{"location":"prog_lang/learning_python_practices/#41-integers","text":"# Integers a = 3 b = 2 # Addition print('Addition: ', a + b) # Substraction print('Substraction: ', a - b) # Multiplication print('Multiplication: ', a * b) # True division print('True division: ', a / b) # Integer division print('Integer division', a // b) # Modulo operation (reminder of a division) print('Modulo division: ', a % b) # Power Division print('Power operation: ', a ** b) # Division with negative number a = -3 b = 2 print('True Division: ', a / b) print('Integer Division: ', a // b) # Retain print('1- Python integers have an unlimited range, subject only to the available virtual memory') print('2- Integer division in Python is always rounded toward minus infinity') print('3- Truncation towards zero is done with the built-i int function') Addition: 5 Substraction: 1 Multiplication: 6 True division: 1.5 Integer division 1 Modulo division: 1 Power operation: 9 True Division: -1.5 Integer Division: -2 1- Python integers have an unlimited range, subject only to the available virtual memory 2- Integer division in Python is always rounded toward minus infinity 3- Truncation towards zero is done with the built-i int function n = 1_024 print(n) hex_n = 0x_4_0_0 print(hex_n) 1024 1024","title":"4.1 Integers"},{"location":"prog_lang/learning_python_practices/#42-booleans","text":"int(True) 1 int(False) 0 bool(1) True bool(0) False bool(123) True bool(-23) True 1 + True 2 False + 42 42 7 - True 6","title":"4.2. Booleans"},{"location":"prog_lang/learning_python_practices/#43-real-numbers","text":"pi = 3.1415926536 radius = 4.5 area = pi * (radius ** 2) print(area) 63.617251235400005 import sys print(sys.float_info) sys.float_info(max=1.7976931348623157e+308, max_exp=1024, max_10_exp=308, min=2.2250738585072014e-308, min_exp=-1021, min_10_exp=-307, dig=15, mant_dig=53, epsilon=2.220446049250313e-16, radix=2, rounds=1) 0.3 - 0.1 * 3 -5.551115123125783e-17","title":"4.3. Real numbers"},{"location":"prog_lang/learning_python_practices/#44-complex-numbers","text":"c = 3.14 + 2.73j print(c) (3.14+2.73j) c = complex(3.14, 2.73) print(c) (3.14+2.73j) type(c) complex c.real 3.14 c.imag 2.73 c.conjugate() (3.14-2.73j) c * 2 (6.28+5.46j) c ** 2 (2.4067000000000007+17.1444j) d = 1 + 1j c - d (2.14+1.73j)","title":"4.4. Complex numbers"},{"location":"prog_lang/learning_python_practices/#45-fractions-and-decimals","text":"from fractions import Fraction f = Fraction(10, 6) print(f) 5/3 type(f) fractions.Fraction f.numerator 5 f.denominator 3 i = f.as_integer_ratio() print(i) print(type(i)) (5, 3) <class 'tuple'> from decimal import Decimal as D D(3.14) Decimal('3.140000000000000124344978758017532527446746826171875') D('3.14') Decimal('3.14') D(0.1) * D(3) - D(0.3) Decimal('2.775557561565156540423631668E-17') D('0.1') * D(3) - D('0.3') Decimal('0.0') D('1.4').as_integer_ratio() (7, 5)","title":"4.5. Fractions and Decimals"},{"location":"prog_lang/learning_python_practices/#5-immutable-sequences","text":"","title":"5. Immutable sequences"},{"location":"prog_lang/learning_python_practices/#51-strings-and-bytes","text":"str1 = 'This is a string. We built it with single quotes' str2 = \"This is also a string, but built with double quotes\" str3 = '''This is built using triple quotes, so it can span multiple lines.''' str4 = \"\"\"This too is a multiline one built with triple double-quotes\"\"\" str4 'This too\\nis a multiline one\\nbuilt with triple double-quotes' print(str4) This too is a multiline one built with triple double-quotes str4_1 = repr(str4) print(str4_1) 'This too\\nis a multiline one\\nbuilt with triple double-quotes' str4_1 \"'This too\\\\nis a multiline one\\\\nbuilt with triple double-quotes'\" str4_2 = str(str4) print(str4_2) This too is a multiline one built with triple double-quotes str4_2 'This too\\nis a multiline one\\nbuilt with triple double-quotes' help(repr) Help on built-in function repr in module builtins: repr(obj, /) Return the canonical string representation of the object. For many object types, including most builtins, eval(repr(obj)) == obj. help(str) Help on class str in module builtins: class str(object) | str(object='') -> str | str(bytes_or_buffer[, encoding[, errors]]) -> str | | Create a new string object from the given object. If encoding or | errors is specified, then the object must expose a data buffer | that will be decoded using the given encoding and error handler. | Otherwise, returns the result of object.__str__() (if defined) | or repr(object). | encoding defaults to sys.getdefaultencoding(). | errors defaults to 'strict'. | | Methods defined here: | | __add__(self, value, /) | Return self+value. | | __contains__(self, key, /) | Return key in self. | | __eq__(self, value, /) | Return self==value. | | __format__(self, format_spec, /) | Return a formatted version of the string as described by format_spec. | | __ge__(self, value, /) | Return self>=value. | | __getattribute__(self, name, /) | Return getattr(self, name). | | __getitem__(self, key, /) | Return self[key]. | | __getnewargs__(...) | | __gt__(self, value, /) | Return self>value. | | __hash__(self, /) | Return hash(self). | | __iter__(self, /) | Implement iter(self). | | __le__(self, value, /) | Return self<=value. | | __len__(self, /) | Return len(self). | | __lt__(self, value, /) | Return self<value. | | __mod__(self, value, /) | Return self%value. | | __mul__(self, value, /) | Return self*value. | | __ne__(self, value, /) | Return self!=value. | | __repr__(self, /) | Return repr(self). | | __rmod__(self, value, /) | Return value%self. | | __rmul__(self, value, /) | Return value*self. | | __sizeof__(self, /) | Return the size of the string in memory, in bytes. | | __str__(self, /) | Return str(self). | | capitalize(self, /) | Return a capitalized version of the string. | | More specifically, make the first character have upper case and the rest lower | case. | | casefold(self, /) | Return a version of the string suitable for caseless comparisons. | | center(self, width, fillchar=' ', /) | Return a centered string of length width. | | Padding is done using the specified fill character (default is a space). | | count(...) | S.count(sub[, start[, end]]) -> int | | Return the number of non-overlapping occurrences of substring sub in | string S[start:end]. Optional arguments start and end are | interpreted as in slice notation. | | encode(self, /, encoding='utf-8', errors='strict') | Encode the string using the codec registered for encoding. | | encoding | The encoding in which to encode the string. | errors | The error handling scheme to use for encoding errors. | The default is 'strict' meaning that encoding errors raise a | UnicodeEncodeError. Other possible values are 'ignore', 'replace' and | 'xmlcharrefreplace' as well as any other name registered with | codecs.register_error that can handle UnicodeEncodeErrors. | | endswith(...) | S.endswith(suffix[, start[, end]]) -> bool | | Return True if S ends with the specified suffix, False otherwise. | With optional start, test S beginning at that position. | With optional end, stop comparing S at that position. | suffix can also be a tuple of strings to try. | | expandtabs(self, /, tabsize=8) | Return a copy where all tab characters are expanded using spaces. | | If tabsize is not given, a tab size of 8 characters is assumed. | | find(...) | S.find(sub[, start[, end]]) -> int | | Return the lowest index in S where substring sub is found, | such that sub is contained within S[start:end]. Optional | arguments start and end are interpreted as in slice notation. | | Return -1 on failure. | | format(...) | S.format(*args, **kwargs) -> str | | Return a formatted version of S, using substitutions from args and kwargs. | The substitutions are identified by braces ('{' and '}'). | | format_map(...) | S.format_map(mapping) -> str | | Return a formatted version of S, using substitutions from mapping. | The substitutions are identified by braces ('{' and '}'). | | index(...) | S.index(sub[, start[, end]]) -> int | | Return the lowest index in S where substring sub is found, | such that sub is contained within S[start:end]. Optional | arguments start and end are interpreted as in slice notation. | | Raises ValueError when the substring is not found. | | isalnum(self, /) | Return True if the string is an alpha-numeric string, False otherwise. | | A string is alpha-numeric if all characters in the string are alpha-numeric and | there is at least one character in the string. | | isalpha(self, /) | Return True if the string is an alphabetic string, False otherwise. | | A string is alphabetic if all characters in the string are alphabetic and there | is at least one character in the string. | | isascii(self, /) | Return True if all characters in the string are ASCII, False otherwise. | | ASCII characters have code points in the range U+0000-U+007F. | Empty string is ASCII too. | | isdecimal(self, /) | Return True if the string is a decimal string, False otherwise. | | A string is a decimal string if all characters in the string are decimal and | there is at least one character in the string. | | isdigit(self, /) | Return True if the string is a digit string, False otherwise. | | A string is a digit string if all characters in the string are digits and there | is at least one character in the string. | | isidentifier(self, /) | Return True if the string is a valid Python identifier, False otherwise. | | Call keyword.iskeyword(s) to test whether string s is a reserved identifier, | such as \"def\" or \"class\". | | islower(self, /) | Return True if the string is a lowercase string, False otherwise. | | A string is lowercase if all cased characters in the string are lowercase and | there is at least one cased character in the string. | | isnumeric(self, /) | Return True if the string is a numeric string, False otherwise. | | A string is numeric if all characters in the string are numeric and there is at | least one character in the string. | | isprintable(self, /) | Return True if the string is printable, False otherwise. | | A string is printable if all of its characters are considered printable in | repr() or if it is empty. | | isspace(self, /) | Return True if the string is a whitespace string, False otherwise. | | A string is whitespace if all characters in the string are whitespace and there | is at least one character in the string. | | istitle(self, /) | Return True if the string is a title-cased string, False otherwise. | | In a title-cased string, upper- and title-case characters may only | follow uncased characters and lowercase characters only cased ones. | | isupper(self, /) | Return True if the string is an uppercase string, False otherwise. | | A string is uppercase if all cased characters in the string are uppercase and | there is at least one cased character in the string. | | join(self, iterable, /) | Concatenate any number of strings. | | The string whose method is called is inserted in between each given string. | The result is returned as a new string. | | Example: '.'.join(['ab', 'pq', 'rs']) -> 'ab.pq.rs' | | ljust(self, width, fillchar=' ', /) | Return a left-justified string of length width. | | Padding is done using the specified fill character (default is a space). | | lower(self, /) | Return a copy of the string converted to lowercase. | | lstrip(self, chars=None, /) | Return a copy of the string with leading whitespace removed. | | If chars is given and not None, remove characters in chars instead. | | partition(self, sep, /) | Partition the string into three parts using the given separator. | | This will search for the separator in the string. If the separator is found, | returns a 3-tuple containing the part before the separator, the separator | itself, and the part after it. | | If the separator is not found, returns a 3-tuple containing the original string | and two empty strings. | | replace(self, old, new, count=-1, /) | Return a copy with all occurrences of substring old replaced by new. | | count | Maximum number of occurrences to replace. | -1 (the default value) means replace all occurrences. | | If the optional argument count is given, only the first count occurrences are | replaced. | | rfind(...) | S.rfind(sub[, start[, end]]) -> int | | Return the highest index in S where substring sub is found, | such that sub is contained within S[start:end]. Optional | arguments start and end are interpreted as in slice notation. | | Return -1 on failure. | | rindex(...) | S.rindex(sub[, start[, end]]) -> int | | Return the highest index in S where substring sub is found, | such that sub is contained within S[start:end]. Optional | arguments start and end are interpreted as in slice notation. | | Raises ValueError when the substring is not found. | | rjust(self, width, fillchar=' ', /) | Return a right-justified string of length width. | | Padding is done using the specified fill character (default is a space). | | rpartition(self, sep, /) | Partition the string into three parts using the given separator. | | This will search for the separator in the string, starting at the end. If | the separator is found, returns a 3-tuple containing the part before the | separator, the separator itself, and the part after it. | | If the separator is not found, returns a 3-tuple containing two empty strings | and the original string. | | rsplit(self, /, sep=None, maxsplit=-1) | Return a list of the words in the string, using sep as the delimiter string. | | sep | The delimiter according which to split the string. | None (the default value) means split according to any whitespace, | and discard empty strings from the result. | maxsplit | Maximum number of splits to do. | -1 (the default value) means no limit. | | Splits are done starting at the end of the string and working to the front. | | rstrip(self, chars=None, /) | Return a copy of the string with trailing whitespace removed. | | If chars is given and not None, remove characters in chars instead. | | split(self, /, sep=None, maxsplit=-1) | Return a list of the words in the string, using sep as the delimiter string. | | sep | The delimiter according which to split the string. | None (the default value) means split according to any whitespace, | and discard empty strings from the result. | maxsplit | Maximum number of splits to do. | -1 (the default value) means no limit. | | splitlines(self, /, keepends=False) | Return a list of the lines in the string, breaking at line boundaries. | | Line breaks are not included in the resulting list unless keepends is given and | true. | | startswith(...) | S.startswith(prefix[, start[, end]]) -> bool | | Return True if S starts with the specified prefix, False otherwise. | With optional start, test S beginning at that position. | With optional end, stop comparing S at that position. | prefix can also be a tuple of strings to try. | | strip(self, chars=None, /) | Return a copy of the string with leading and trailing whitespace removed. | | If chars is given and not None, remove characters in chars instead. | | swapcase(self, /) | Convert uppercase characters to lowercase and lowercase characters to uppercase. | | title(self, /) | Return a version of the string where each word is titlecased. | | More specifically, words start with uppercased characters and all remaining | cased characters have lower case. | | translate(self, table, /) | Replace each character in the string using the given translation table. | | table | Translation table, which must be a mapping of Unicode ordinals to | Unicode ordinals, strings, or None. | | The table must implement lookup/indexing via __getitem__, for instance a | dictionary or list. If this operation raises LookupError, the character is | left untouched. Characters mapped to None are deleted. | | upper(self, /) | Return a copy of the string converted to uppercase. | | zfill(self, width, /) | Pad a numeric string with zeros on the left, to fill a field of the given width. | | The string is never truncated. | | ---------------------------------------------------------------------- | Static methods defined here: | | __new__(*args, **kwargs) from builtins.type | Create and return a new object. See help(type) for accurate signature. | | maketrans(...) | Return a translation table usable for str.translate(). | | If there is only one argument, it must be a dictionary mapping Unicode | ordinals (integers) or characters to Unicode ordinals, strings or None. | Character keys will be then converted to ordinals. | If there are two arguments, they must be strings of equal length, and | in the resulting dictionary, each character in x will be mapped to the | character at the same position in y. If there is a third argument, it | must be a string, whose characters will be mapped to None in the result. # Python >=3.9 s = 'Hello There' s.removeprefix('Hell') s.removesuffix('here') s.removeprefix('Ooops') --------------------------------------------------------------------------- AttributeError Traceback (most recent call last) <ipython-input-80-40b1b20ef836> in <module> 1 s = 'Hello There' ----> 2 s.removeprefix('Hell') 3 s.removesuffix('here') 4 s.removeprefix('Ooops') AttributeError: 'str' object has no attribute 'removeprefix' s = \"this is \u00e9l\u00e8ve\" type(s) str encoded_s = s.encode('utf-8') encoded_s b'this is \\xc3\\xa9l\\xc3\\xa8ve' type(encoded_s) bytes encoded_s.decode('utf-8') 'this is \u00e9l\u00e8ve' for b in encoded_s: print(f'{b} : {type(b)}') 116 : <class 'int'> 104 : <class 'int'> 105 : <class 'int'> 115 : <class 'int'> 32 : <class 'int'> 105 : <class 'int'> 115 : <class 'int'> 32 : <class 'int'> 195 : <class 'int'> 169 : <class 'int'> 108 : <class 'int'> 195 : <class 'int'> 168 : <class 'int'> 118 : <class 'int'> 101 : <class 'int'> your_mantra = \"The trouble is you think you have time\" your_mantra[0] 'T' your_mantra[5] 'r' your_mantra[:4] 'The ' your_mantra[4:] 'trouble is you think you have time' your_mantra[2:14] 'e trouble is' your_mantra[2:14:3] 'erb ' your_mantra[:] #Easy way to get copy of a string 'The trouble is you think you have time' your_mantra[-1::-1] #Reverse of a string from slicing 'emit evah uoy kniht uoy si elbuort ehT' # Deprecated greet_old = 'Hello %s!' greet_old % 'Fabrizio' 'Hello Fabrizio!' greet_positional = 'Hello {}!' greet_positional.format('Fabrizio') 'Hello Fabrizio!' greet_positional = 'Hello {} {}!' greet_positional.format('Abari', 'Kader') 'Hello Abari Kader!' greet_positional_idx = 'This is {0}! {1} is sister to {0}' greet_positional_idx.format('Hawa', 'Asmaou') 'This is Hawa! Asmaou is sister to Hawa' keyword = '{name} is student at {school}.' keyword.format(name='Abari', school='National School of Applied Sciences') 'Abari is student at National School of Applied Sciences.' name = 'Fab' age = 42 f\"Hello! My name is {name} and I'm {age}\" \"Hello! My name is Fab and I'm 42\" from math import pi f\"No arguing with {pi}, it's irrational\" \"No arguing with 3.141592653589793, it's irrational\" user = 'heinrich' password = 'super-secret' f\"Log in with:{user} and {password}\" 'Log in with:heinrich and super-secret' f\"Log in with:{user=} and {password=}\" \"Log in with:user='heinrich' and password='super-secret'\"","title":"5.1 Strings and bytes"},{"location":"prog_lang/learning_python_practices/#52-tuples","text":"t = () type(t) tuple one_element_tuple = (32, ) three_elements_tuple = (1, 3, 5) a, b, c = 1, 2, 3 a, b, c (1, 2, 3) a, b = 1, 2 c = a a = b b = c print(a, b) 2 1 a, b = 3, 4 a, b = b, a print(a, b) 4 3","title":"5.2 Tuples"},{"location":"prog_lang/learning_python_practices/#6-mutable-sequences","text":"","title":"6. Mutable Sequences"},{"location":"prog_lang/learning_python_practices/#61-lists","text":"[] [] list() [] [1, 2, 3] [1, 2, 3] [x + 5 for x in [2, 3, 4]] [7, 8, 9] list('Hello') ['H', 'e', 'l', 'l', 'o'] a = [1, 2, 1, 3] a.append(13) print(a) [1, 2, 1, 3, 13] a.count(1) print(a) [1, 2, 1, 3, 13] a.extend([5, 7]) print(a) [1, 2, 1, 3, 13, 5, 7] a.index(13) print(a) [1, 2, 1, 3, 13, 5, 7] a.insert(0, 17) print(a) [17, 1, 2, 1, 3, 13, 5, 7] a.pop() 7 a.pop(3) 1 a [17, 1, 2, 3, 13, 5] a.sort() print(a) [1, 2, 3, 5, 13, 17] a.clear() print(a) [] a = [1, 3, 5, 7] min(a) 1 max(a) 7 sum(a) 16 from math import prod prod(a) 105 len(a) 4 b = [6, 7, 8] a + b [1, 3, 5, 7, 6, 7, 8] a * 2 [1, 3, 5, 7, 1, 3, 5, 7] from operator import itemgetter a = [(5, 3), (1, 3), (1, 2), (2, -1), (4, 9)] sorted(a) [(1, 2), (1, 3), (2, -1), (4, 9), (5, 3)] sorted(a, key=itemgetter(0, 1)) [(1, 2), (1, 3), (2, -1), (4, 9), (5, 3)] sorted(a, key=itemgetter(1)) [(2, -1), (1, 2), (5, 3), (1, 3), (4, 9)] sorted(a, key=itemgetter(1), reverse=True) [(4, 9), (5, 3), (1, 3), (1, 2), (2, -1)]","title":"6.1 Lists"},{"location":"prog_lang/learning_python_practices/#62-bytearrays","text":"bytearray() bytearray(b'') b = bytearray(10) bytearray(range(5)) bytearray(b'\\x00\\x01\\x02\\x03\\x04') name = bytearray(b'Lina') name.replace(b'L', b'l') bytearray(b'lina') name.endswith(b'na') True name.upper() bytearray(b'LINA') name.count(b'L') 1 print(name) bytearray(b'Lina') name.decode('utf8') 'Lina' byte = bytearray([66, 65, 124, 123]) byte.decode('utf') 'BA|{'","title":"6.2 Bytearrays"},{"location":"prog_lang/learning_python_practices/#7-set-types","text":"small_primes = set() small_primes.add(2) small_primes.add(3) small_primes.add(5) print(small_primes) {2, 3, 5} small_primes.add(1) print(small_primes) small_primes.remove(1) print(small_primes) {1, 2, 3, 5} {2, 3, 5} 3 in small_primes True 4 not in small_primes True small_primes.add(3) print(small_primes) {2, 3, 5} bigger_primes = set([5, 7, 11, 13]) small_primes | bigger_primes {2, 3, 5, 7, 11, 13} small_primes & bigger_primes {5} small_primes - bigger_primes {2, 3} small_primes = {2, 3, 5, 5, 3} small_primes {2, 3, 5} small_primes_2 = frozenset([2, 3, 5, 7]) bigger_primes_2 = frozenset([5, 7, 11]) small_primes_2.add(11) --------------------------------------------------------------------------- AttributeError Traceback (most recent call last) <ipython-input-140-f9612be082dd> in <module> ----> 1 small_primes_2.add(11) AttributeError: 'frozenset' object has no attribute 'add' small_primes_2.remove(2) --------------------------------------------------------------------------- AttributeError Traceback (most recent call last) <ipython-input-141-09c0bc2b75a9> in <module> ----> 1 small_primes_2.remove(2) AttributeError: 'frozenset' object has no attribute 'remove' small_primes_2 & bigger_primes_2 frozenset({5, 7}) small_primes_2 | bigger_primes_2 frozenset({2, 3, 5, 7, 11})","title":"7 Set types"},{"location":"prog_lang/learning_python_practices/#8-mapping-types-dictionaries","text":"a = dict(A=1, Z=-1) b = {'A': 1, 'Z': -1} c = dict(zip(['A', 'Z'], [1, -1])) d = dict([('A', 1), ('Z', -1)]) e = dict({'Z': -1, 'A': 1}) a == b == c == d == e True list(zip('Hello', range(1, 6))) [('H', 1), ('e', 2), ('l', 3), ('l', 4), ('o', 5)] d = dict(zip('hello', range(5))) print(d) {'h': 0, 'e': 1, 'l': 3, 'o': 4} k = d.keys() v = d.values() items = d.items() 3 in d.values() True ('o', 4) in d.items() True d.popitem() ('o', 4) d.pop('l') 3 d.pop('not-a-key') --------------------------------------------------------------------------- KeyError Traceback (most recent call last) <ipython-input-166-79ca84a85bcf> in <module> ----> 1 d.pop('not-a-key') KeyError: 'not-a-key' d.pop('not-a-key', 'default-value') 'default-value' d.update({'another': 'value'}) d.update(a=13) d {'h': 0, 'e': 1, 'another': 'value', 'a': 13} d.get('a', 177) 13 d.get('b', 177) 177 d.get('b') d {'h': 0, 'e': 1, 'another': 'value', 'a': 13} d = {} d.setdefault('a', 1) 1 d {'a': 1} {'a': {'b': [1]}} {'a': {'b': [1]}} d = {} d.setdefault('a', {}).setdefault('b', []).append(1) d {'a': {'b': [1]}}","title":"8. Mapping types : dictionaries"},{"location":"prog_lang/learning_python_practices/#9-dates-and-times","text":"from datetime import date, datetime, timedelta, timezone import time import calendar as cal #from zoneinfo import ZoneInfo today = date.today() type(today) datetime.date print(today) 2022-05-15 today.ctime() 'Sun May 15 00:00:00 2022' today.isoformat() '2022-05-15' today.weekday() 6 cal.day_name[today.weekday()] 'Sunday' today.day, today.month, today.year (15, 5, 2022) today.timetuple() time.struct_time(tm_year=2022, tm_mon=5, tm_mday=15, tm_hour=0, tm_min=0, tm_sec=0, tm_wday=6, tm_yday=135, tm_isdst=-1) time.ctime() 'Mon May 16 00:56:02 2022' time.daylight 0 time.gmtime() time.struct_time(tm_year=2022, tm_mon=5, tm_mday=15, tm_hour=23, tm_min=57, tm_sec=8, tm_wday=6, tm_yday=135, tm_isdst=0) time.gmtime(0) time.struct_time(tm_year=1970, tm_mon=1, tm_mday=1, tm_hour=0, tm_min=0, tm_sec=0, tm_wday=3, tm_yday=1, tm_isdst=0) time.localtime() time.struct_time(tm_year=2022, tm_mon=5, tm_mday=16, tm_hour=0, tm_min=57, tm_sec=56, tm_wday=0, tm_yday=136, tm_isdst=0) time.time() 1652659085.3439333 now = datetime.now() utcnow = datetime.utcnow() now datetime.datetime(2022, 5, 16, 1, 7, 43, 328210) utcnow datetime.datetime(2022, 5, 16, 0, 0, 31, 881436) now.date() datetime.date(2022, 5, 16) now.day, now.month, now.year (16, 5, 2022) now.date() == date.today() True now.time() datetime.time(1, 0, 20, 405250) now.hour, now.minute, now.second, now.microsecond (1, 0, 20, 405250) now.ctime() 'Mon May 16 01:07:43 2022' now.isoformat() '2022-05-16T01:07:43.328210' now.timetuple() time.struct_time(tm_year=2022, tm_mon=5, tm_mday=16, tm_hour=1, tm_min=0, tm_sec=20, tm_wday=0, tm_yday=136, tm_isdst=-1) now.tzinfo utcnow.tzinfo now.weekday() 0 f_bday = datetime(1997, 10, 5, 14, 5) f_bday.isoformat() '1997-10-05T14:05:00' h_bday = f_bday + timedelta(days=365) h_bday == datetime(1998, 10, 5, 14, 5) True","title":"9. Dates and times"},{"location":"prog_lang/learning_python_practices/#10-the-collections-module","text":"","title":"10. The collections module"},{"location":"prog_lang/learning_python_practices/#101-namedtuple","text":"vision = (9.5, 8.8) vision (9.5, 8.8) vision[0] 9.5 vision[1] 8.8 from collections import namedtuple Vision = namedtuple('Vision', ['left', 'right']) vision = Vision(9.5, 8.8) vision[0] 9.5 vision[1] 8.8 vision.left 9.5 vision.right 8.8 Vision = namedtuple('Vision', ['left', 'combined', 'right']) vision = Vision(9.5, 9.2, 8.8) vision.left 9.5 vision.right 8.8 vision.combined 9.2","title":"10.1 Namedtuple"},{"location":"prog_lang/learning_python_practices/#102-defaultdict","text":"d = {} d['age'] = d.get('age', 0) + 1 d {'age': 1} d = {'age': 39} d['age'] = d.get('age', 0) + 1 d {'age': 40} from collections import defaultdict dd = defaultdict(int) dd['age'] +=1 dd['gpa'] += 4 dd defaultdict(int, {'age': 1, 'gpa': 4})","title":"10.2 defaultdict"},{"location":"prog_lang/learning_python_practices/#103-chainmap","text":"from collections import ChainMap default_connection = {'host': 'localhost', 'port': 4567} connection = {'port': 5678} conn = ChainMap(connection, default_connection) conn['port'] 5678 conn['host'] 'localhost' conn.maps [{'port': 5678}, {'host': 'localhost', 'port': 4567}] conn['host'] = 'packtpub.com' conn.maps [{'port': 5678, 'host': 'packtpub.com'}, {'host': 'localhost', 'port': 4567}] del conn['port'] conn.maps [{'host': 'packtpub.com'}, {'host': 'localhost', 'port': 4567}] conn['port'] 4567 dict(conn) {'host': 'packtpub.com', 'port': 4567}","title":"10.3 ChainMap"},{"location":"prog_lang/learning_python_practices/#104-enums","text":"GREEN = 1 YELLOW = 2 RED = 4 TRAFFIC_LIGHTS = (GREEN, YELLOW, RED) traffic_lights = {'GREEN': 1, 'YELLOW': 2, 'RED': 4} from enum import Enum class TrafficLight(Enum): GREEN = 1 YELLOW = 2 RED = 4 TrafficLight.GREEN <TrafficLight.GREEN: 1> TrafficLight.GREEN.value 1 TrafficLight(4) <TrafficLight.RED: 4>","title":"10.4 Enums"},{"location":"prog_lang/learning_python_practices/#11-small-value-caching","text":"a = 1000000 b = 1000000 id(a) == id(b) False a = 5 b = 5 id(a) == id(b) True a = 5 b = 6 id(a) == id(b) False a = 6 id(a) == id(b) True c = 6 id(a) == id(b) True","title":"11. Small value caching"},{"location":"prog_lang/python/","text":"Python Programming Introduction How to use Python interpreter How to use PIP How to use IPython Virtual Environment anaconda distribution","title":"Other"},{"location":"prog_lang/python/#python-programming","text":"","title":"Python Programming"},{"location":"prog_lang/python/#introduction","text":"","title":"Introduction"},{"location":"prog_lang/python/#how-to-use-python-interpreter","text":"","title":"How to use Python interpreter"},{"location":"prog_lang/python/#how-to-use-pip","text":"","title":"How to use PIP"},{"location":"prog_lang/python/#how-to-use-ipython","text":"","title":"How to use IPython"},{"location":"prog_lang/python/#virtual-environment","text":"","title":"Virtual Environment"},{"location":"prog_lang/python/#anaconda-distribution","text":"","title":"anaconda distribution"},{"location":"prog_lang/python_lang/","text":"","title":"Python lang"}]}